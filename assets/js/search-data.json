{"0": {
    "doc": "Access Controls",
    "title": "Access Controls",
    "content": "Basis Theory secures sensitive data as Tokens that are stored within an isolated compliant environment, called a Tenant. Your systems interact with Tokens or Services (e.g. Proxy, Reactors) through the Basis Theory API using an API key that is issued to an Application. Access to your Tenant’s data is limited by applying access controls to an Application via Permissions and Access Rules to ensure services and users only have access to the data they need. | What are Tenants? . | Common Use Cases for Tenants . | Enabling Your Software Development Life Cycle | Separating Data by Business Unit | . | . | What are Applications? . | Name | Application Type | Access Controls . | Permissions | Access Rules | . | API Key | Expires At | Can Create Expiring Applications | Application Templates | Common Use Cases for Applications . | Grant Multiple Systems Access Following the Principle of Least Privilege | Enable partners to use data secured by Basis Theory | Manage Basis Theory Assets with Infrastructure as Code | . | . | What are Access Rules? . | Description | Container | Conditions | Permissions | Transform | Priority | Common Use Cases for Access Rules . | Grant Access to a Single Data Classification | Grant Access to a Single Customer’s Data | . | . | . ",
    "url": "https://developers.basistheory.com/concepts/access-controls/",
    "relUrl": "/concepts/access-controls/"
  },"1": {
    "doc": "Access Controls",
    "title": "What are Tenants?",
    "content": "Everything starts with a Tenant in your Basis Theory account. Tenants represent an isolated environment in which your Tokens and other resources are defined, managed, and stored. Data is not shared between Tenants, but you’re allowed to create as many Tenants as you’d like within Basis Theory. You can use multiple Tenants to isolate different domains of data, and to support your Software Development Life Cycle (SDLC). The user account that was used to create a Tenant in the Portal will be designated as the Tenant Owner. New members can be invited to an existing Tenant through the Members tab. Managing Tenant Members can also be done directly through the API. Common Use Cases for Tenants . Enabling Your Software Development Life Cycle . Companies producing software typically create separate and identical environments to support their development and release processes. For example, developers and teams create Production environments to house their actual customer data and multiple non-Production environments to enable quick development and testing of their applications without impacting their Production systems. Basis Theory allows you to create these logical separations of data by creating a new Tenant for each environment: . Separating Data by Business Unit . Many large enterprise and corporate organizations have multiple business units or properties which have different data needs. Some business units may not want other parts of the organization to have direct access to data they own and manage. Creating a Tenant for each business unit enables your organization to isolate and limit access to their data by issuing an Application with limited access controls to other units within the organization. ",
    "url": "https://developers.basistheory.com/concepts/access-controls/#what-are-tenants",
    "relUrl": "/concepts/access-controls/#what-are-tenants"
  },"2": {
    "doc": "Access Controls",
    "title": "What are Applications?",
    "content": "An Application represents an external software system or service that will be integrated with the Basis Theory API. Basis Theory’s Applications are not coupled to a specific implementation type or technology. Applications could be a native app on a mobile device, a single-page application in a browser, or a backend service that executes on a server or in a serverless environment. Applications within Basis Theory have the following properties and characteristics: . Name . A short description of the Application describing its intended use, for example “Acme Billing App” or “Acme Mobile App”. Application Type . | Private: Used by a backend system or service that runs primarily on a server or in a serverless environment (e.g. NodeJs, .NET, Java, or Ruby). Private Applications allow the broadest access to Token data as the API Key is expected to be kept private and secured within your systems. | Public: Used for Browser, Mobile, or Desktop applications running natively on a device (e.g. iOS, Android, Windows, etc) where the application is collecting data for tokenization via an API call or using Basis Theory Elements. Public Applications have limited permissions available to ensure the API Key can be safely used within publicly available code. | Management: Used with scripts or the Basis Theory Terraform (request access here) modules to manage your Tenant’s settings and services (Applications, Reactors, Proxy, etc) without logging into our Portal. | Expiring: Used for Browser, Mobile, or Desktop applications running natively on a device (e.g. iOS, Android, Windows, etc) where the application is revealing sensitive data using Basis Theory Elements. Expiring Applications have limited permissions available and can be scoped to single tokens to ensure the API Key can be safely used within publicly available code. | . Access Controls . An Application is granted access to your Tenant’s resources in one of two ways: by granting the Application a set of Permissions, or for more advanced scenarios, by defining one or more Access Rules. Permissions . For basic authorization scenarios, an Application can simply be granted one or more permissions. Each Application Type allows a different set of permissions, and you can find a detailed list of them here. Token permissions granted to Private or Public applications are applied to all Tokens (i.e. they are not scoped to a particular Container of Tokens). In order to ensure sensitive data is not inadvertently revealed by an Application, an implicit transform is applied for each operation: . | Permission | Transform | . | token:create | mask | . | token:update | mask | . | token:read | mask | . | token:search | mask | . | token:use | reveal | . | token:delete | N/A | . This behavior can be customized by defining Access Rules. Access Rules . For more advanced authorization scenarios, Access Rules enable scoping a set of permissions to a subset of Tokens, and to customize the behavior when returning Token data from the API. Please see the section on What are Access Rules below for more details. API Key . Your Application’s API Key is used to authenticate your systems to the Basis Theory platform. The API Key can be used to make authenticated requests to our API directly, using Hosted Elements, or using the Basis Theory SDK. These API Keys follow a format similar to key_4qUtg83907AnDem90aJSzcN. API Keys should be regarded as highly sensitive, and should be stored a secret within in your environments. Expires At . ISO8601 compatible DateTime at which the application will be deleted. It only applies for Expiring applications. Can Create Expiring Applications . Flag that determines whether a Private application can provision Expiring applications. Application Templates . To help you get started quickly, we provide a set of Application Templates for many common use cases, such as Payments, Banking, and PII Data. The available application templates are presented after clicking on the “Create Application” button in the Portal. If you are just getting started with Basis Theory, the Full Access template can be useful for testing and prototyping. This template will create a test Application that has been granted all permissions for interacting with Tokens within your Tenant. It is important to remember that the Full Access template should not be used for production Applications, and you should always strive to follow the principle of least privilege. Selecting a template will only pre-fill the Create Application form, and any settings or access rules within the Application can be customized. Once created, your Application will have no relationship with the template and can be updated independently. If you have a particular use case that is not covered by one of the existing templates, you can also create a custom Application to satisfy your specific requirements by choosing the Create Your Own option. Common Use Cases for Applications . Grant Multiple Systems Access Following the Principle of Least Privilege . A common use-case for Applications is to grant minimal access to multiple systems where each system is only authorized to perform necessary operations and access a relevant subset of data within a Tenant. This could mean that one system is only allowed to collect Tokenized data, another system is allowed to read the data to perform analytics, and a third system is only allowed to Proxy the data to an integrated 3rd party but never access the raw data. Enable partners to use data secured by Basis Theory . Often, businesses need to grant their partners access to their sensitive data — traditionally, these businesses would just export the needed data and send it to their partner. With Basis Theory Applications, a business can create an Application that is restricted to ONLY the data that partner needs. In some cases, businesses will not allow their partners direct access to the raw data, but rather only allow them to Proxy the data to another API or execute serverless workloads on the sensitive data using Reactors. Manage Basis Theory Assets with Infrastructure as Code . The Management application type allows the Basis Theory platform to be configured entirely via our API. This enables engineers to write scripts or to use IaC (Infrastructure as Code) tooling such as Terraform to manage your Tenants and Services without logging into our Portal UI. ",
    "url": "https://developers.basistheory.com/concepts/access-controls/#what-are-applications",
    "relUrl": "/concepts/access-controls/#what-are-applications"
  },"3": {
    "doc": "Access Controls",
    "title": "What are Access Rules?",
    "content": "Access Rules are the building blocks for constructing fine-grained access control policies for an Application. When performing an operation through the Basis Theory API, Access Rules are evaluated in priority order until the first rule is found with matching container or conditions. Once a matching rule is identified, the transform defined on the rule determines if and how Token data will be returned from the API. If no matching rules are found, access to the requested resource is denied with a 403 Forbidden error. Access Rules are currently only supported on Private, Public and Expiring Application types, and only control access to Token resources. Access Rules are not supported on Management Applications at this time. Access Rules are comprised of the following properties: . Description . A short description of the rule to help you identify its purpose. Container . Access Rules can be scoped to a specific set of Tokens using Containers. Containers are a Token attribute that enable you to logically organize Tokens into hierarchical paths, similar to a UNIX directory structure. Permissions granted on a Container are inherited on all sub-Containers. For example, having an Access Rule granting token:read permission on the /pci/ Container will allow that Application the ability to read Tokens in the /pci/low/ and /pci/high/ Containers. To specify different access controls on a sub-Container, you may apply another rule with higher priority that is scoped to the sub-Container. For example, given a rule that grants token:read permission on the /pci/high/ Container with a mask transform and another rule with lower priority grants token:read permission on the /pci/ Container with a reveal transform, then reading tokens in the /pci/high/ container will return masked data, and reading tokens in the /pci/low/ container will return plaintext data. Conditions . Conditions allow specifying more specific restrictions for the access rule to be matched, such as scoping them to a specific token. For example, having a condition with attribute ID, operator EQUALS and value &lt;tokenId&gt;, will allow the application to only access the token with the given &lt;tokenId&gt; ID. Conditions are mutually exclusive with Container and are currently only available for Expiring applications. Permissions . One or more permissions to be granted on Tokens in the specified Container. Check out our API docs for a detailed list of supported permissions by Application type. Transform . Transforms are applied to the data property of a Token within API responses, allowing you to specify which view of the data is appropriate to expose to the Application. The following transforms are supported: . | redact - redacts the data property from Tokens | mask - returns masked data if a mask expression is defined on the Token, otherwise data is redacted | reveal - returns the original plaintext data | . Be cautious whenever applying a reveal transform. This is especially true when granting the token:read or token:search permissions, as this will allow your Application to read plaintext data. This may result in your systems being pulled into compliance scope. Priority . Each access rule is assigned a unique priority value, which specifies the order in which the rules will be evaluated. Rules are evaluated in ascending priority order, with the lowest numerical value having the highest precedence. Common Use Cases for Access Rules . Grant Access to a Single Data Classification . Access Rules can be scoped to a specific data classification of Tokens. To enable this use case, first ensure your Tokens are organized into classification-based Containers, for example /pci/, /pii/, and /general/. Grant Access to a Single Customer’s Data . Your customers’ sensitive data can be partitioned within Basis Theory, for example, to enable you to offer your customers single-tenant environments that only have access to a single customer’s data. To enable this use case, first ensure your Tokens are organized into Containers by customer, for example /customer-1/, /customer-2/, etc. ",
    "url": "https://developers.basistheory.com/concepts/access-controls/#what-are-access-rules",
    "relUrl": "/concepts/access-controls/#what-are-access-rules"
  },"4": {
    "doc": "Collect Credit Cards with React",
    "title": "Collect Credit Cards with React",
    "content": "Once you’ve completed this guide, you will have learned how your React application can use our Elements to collect and store credit card information on the Basis Theory platform. This simple task enables you to retain control of your card data and enables the use of credit card data with any third party as if you had the data stored in your own database. If you’d like to follow along with this guide from scratch, we suggest creating a new React sandbox using codesandbox.io and getting started from there! Want to jump right into our sample app? Find it here! . This guide is for collecting cards using the single CardElement. In case you prefer to have the card number, expiration date and cvc each in separate elements, check the docs on how to use them here or check out our sample app here. ",
    "url": "https://developers.basistheory.com/guides/collect-cards-with-elements-react/",
    "relUrl": "/guides/collect-cards-with-elements-react/"
  },"5": {
    "doc": "Collect Credit Cards with React",
    "title": "Let’s code",
    "content": "To start, you’ll need a new Public Application with the token:create permission granted to the /pci/ container. Click here to create one. Install our React package: . npm install --save @basis-theory/basis-theory-react . Initialize the Basis Theory SDK passing the API Key to the useBasisTheory hook and wrap your App contents with a BasisTheoryProvider: . import { useBasisTheory, BasisTheoryProvider, } from '@basis-theory/basis-theory-react'; function App() { const { bt } = useBasisTheory(ELEMENTS_API_KEY, { elements: true, }); return ( &lt;BasisTheoryProvider bt={bt}&gt; &lt;!-- rest of app code goes here --&gt; &lt;/BasisTheoryProvider&gt; ); } export default App; . Create a CheckoutForm component and add it inside the BasisTheoryProvider in your App content. Create a ref that will be used to store the underlying elements instance. Declare a CardElement inside it and call the tokenization method tokens.create passing the token’s type (card) and the underlying card element instance: . import { useRef } from 'react'; import { CardElement, useBasisTheory } from '@basis-theory/basis-theory-react'; export const CheckoutForm = () =&gt; { const { bt } = useBasisTheory(); const cardRef = useRef(null); const submit = async () =&gt; { try { const token = await bt.tokens.create({ type: 'card', data: cardRef.current, }); } catch (error) { console.error(error); } }; return ( &lt;&gt; &lt;CardElement id=\"myCard\" ref={cardRef}/&gt; &lt;button id=\"submit_button\" type=\"button\" onClick={submit} &gt; Submit &lt;/button&gt; &lt;/&gt; ); }; . Success! 🎉 Your React application is now collecting and storing credit cards in Basis Theory platform. ",
    "url": "https://developers.basistheory.com/guides/collect-cards-with-elements-react/#lets-code",
    "relUrl": "/guides/collect-cards-with-elements-react/#lets-code"
  },"6": {
    "doc": "Collect Credit Cards with React",
    "title": "Next steps",
    "content": "The Token you’ve created from your frontend application can be used in a variety of ways from within your system, check out a few of those below: . | You can fetch the card data later in your server, using a Private Application Key (click here to create one) to call Get a Token API; | Call one of our Reactors to process that card data. Here is how to charge a card with Node.js; | Make a third party API request with the raw data through our Proxy. Feel free to contact us for more information on how to do it. | . ",
    "url": "https://developers.basistheory.com/guides/collect-cards-with-elements-react/#next-steps",
    "relUrl": "/guides/collect-cards-with-elements-react/#next-steps"
  },"7": {
    "doc": "Collect Credit Cards with React",
    "title": "See it in action",
    "content": "The example below uses a few of the Element’s user experience features to ensure the best experience to your customers: . | Disable the “Submit” &lt;button&gt; while the CardElement information is not complete, by listening to the onChange event; | Disable the CardElement and “Submit” button during the tokenization request inside the submit function; | Display the full token response; | Log any tokenization errors to the console; | . See it running and the code that drives it below. Want to experience the sandbox yourself? Check it out here. ",
    "url": "https://developers.basistheory.com/guides/collect-cards-with-elements-react/#see-it-in-action",
    "relUrl": "/guides/collect-cards-with-elements-react/#see-it-in-action"
  },"8": {
    "doc": "Collect and Charge Credit Cards with JavaScript",
    "title": "Collect and Charge Credit Cards with JavaScript",
    "content": "Once you’ve completed this guide, you will have learned how any website or frontend application can use our Elements to collect, store, and use credit card information with the Basis Theory platform. You’ll also have a foundational understanding of how you can use your credit card data with multiple third-parties as if you had a PCI Level 1 system and were able to store the data within your own database. If you’d like to follow along with this guide from scratch, we suggest creating a new Vanilla JS sandbox using codesandbox.io and getting started from there! Want to jump right into our sample app? Find it here! . Using React? Check out the Collect Credit Cards with React Guide. This guide is for collecting cards using the single CardElement. In case you prefer to have the card number, expiration date and cvc each in separate elements, check the docs on how to use them here or check out our sample app here. | Add Elements to your website | Setup and Use a Token Reactor | Using your new Reactor | Use the reaction data to charge a customer | Use the raw card data whenever you need | . ",
    "url": "https://developers.basistheory.com/guides/collect-cards-with-elements/",
    "relUrl": "/guides/collect-cards-with-elements/"
  },"9": {
    "doc": "Collect and Charge Credit Cards with JavaScript",
    "title": "Add Elements to your website",
    "content": "To start, you’ll need a new Public Application with the token:create permission granted to the /pci/ container. Click here to create one. Using our hosted elements, you can collect cards on any webpage you need to, while maintaining the lowest possible PCI compliance level. &lt;html&gt; &lt;head&gt; &lt;script src=\"https://js.basistheory.com\"&gt;&lt;/script&gt; &lt;script&gt; let card; async function submitCard() { const cardToken = await BasisTheory.tokens.create({ type: 'card', data: card }); console.log(cardToken); } window.addEventListener(\"load\", async () =&gt; { await BasisTheory.init(&lt;ELEMENTS_API_KEY&gt;, { elements: true }); card = BasisTheory.createElement(\"card\", style); await card.mount(\"#card\"); card.on(\"change\", (e) =&gt; { const button = document.getElementById(\"submit_button\"); button.disabled = !e.complete; }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;div id=\"form\"&gt; &lt;div class=\"row\" id=\"card\"&gt;&lt;/div&gt; &lt;button id=\"submit_button\" type=\"button\" onclick=\"submitCard()\"&gt; Submit &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; . ",
    "url": "https://developers.basistheory.com/guides/collect-cards-with-elements/#add-elements-to-your-website",
    "relUrl": "/guides/collect-cards-with-elements/#add-elements-to-your-website"
  },"10": {
    "doc": "Collect and Charge Credit Cards with JavaScript",
    "title": "Setup and Use a Token Reactor",
    "content": "Configure one of our pre-built Reactor Formulas, enabling you to quickly exchange raw card data for a processor token (e.g. Stripe). To set up a Reactor, head over to our Portal and set up a new Stripe Reactor. If you’re looking for step-by-step guide on how to set up a Reactor, head over to our guide. ",
    "url": "https://developers.basistheory.com/guides/collect-cards-with-elements/#setup-and-use-a-token-reactor",
    "relUrl": "/guides/collect-cards-with-elements/#setup-and-use-a-token-reactor"
  },"11": {
    "doc": "Collect and Charge Credit Cards with JavaScript",
    "title": "Using your new Reactor",
    "content": "To use your Stripe Reactor, you’ll need a Private Application with the token:create and token:use permissions granted to the /pci/ container. Click here to create one. Once you’ve created your Stripe Reactor, use the reactor_id and your Card token’s ID to exchange for a Stripe token, which you’ll be able to use to charge your customer. const reactorResponse = await bt.reactors.react(REACTOR_ID, { args: { card: `{{${cardToken.id}}}` } }); return reactorResponse.raw.id; . Now that you have your Stripe Payment Method, you can store this within your own platform and avoid becoming dependent on Basis Theory for your future transactions. As soon as you need a new Stripe Payment Method, just call the /react endpoint for that reactor with your card token id, and you’ll have a newly attached token. ",
    "url": "https://developers.basistheory.com/guides/collect-cards-with-elements/#using-your-new-reactor",
    "relUrl": "/guides/collect-cards-with-elements/#using-your-new-reactor"
  },"12": {
    "doc": "Collect and Charge Credit Cards with JavaScript",
    "title": "Use the reaction data to charge a customer",
    "content": "Now, you’re able to access the token created by your Reactor. You may be using this for analytical BIN information, fraud analytics, or to charge a card using the processor token you’ve created. const stripe = require(\"stripe\")(STRIPE_API_KEY); const paymentIntent = await stripe.paymentIntents.create({ amount: 1099, currency: \"usd\", payment_method: paymentMethodId, // Payment Method from Stripe Reaction in step 2 confirm: true }); return paymentIntent; . ",
    "url": "https://developers.basistheory.com/guides/collect-cards-with-elements/#use-the-reaction-data-to-charge-a-customer",
    "relUrl": "/guides/collect-cards-with-elements/#use-the-reaction-data-to-charge-a-customer"
  },"13": {
    "doc": "Collect and Charge Credit Cards with JavaScript",
    "title": "Use the raw card data whenever you need",
    "content": "With Basis Theory, we enable the highest level of usability for your card data possible. Is your primary processor down? react with a back-up processor. Soft decline and want to reprocess? react with another processor. Want to understand your customers card analytics? react with a BIN List like Parrot. Anything is possible when you store your card data with us. To expand your possibilities, just configure a new Reactor. ",
    "url": "https://developers.basistheory.com/guides/collect-cards-with-elements/#use-the-raw-card-data-whenever-you-need",
    "relUrl": "/guides/collect-cards-with-elements/#use-the-raw-card-data-whenever-you-need"
  },"14": {
    "doc": "Collect and Charge Credit Cards with JavaScript",
    "title": "See it in action",
    "content": "See a sample and the code that drives it below. Want to experience the sandbox yourself? Check it out here. ` . ` . ",
    "url": "https://developers.basistheory.com/guides/collect-cards-with-elements/#see-it-in-action",
    "relUrl": "/guides/collect-cards-with-elements/#see-it-in-action"
  },"15": {
    "doc": "Collect and Use Credit Cards with Proxies",
    "title": "Collect and Use Credit Cards with Proxies",
    "content": "By the end of this guide, you will have learned how to use Basis Theory’s Proxies to accept Credit Card data in your API - all without touching the card data or pulling your system into PCI scope. In this example, we will configure the Proxy to utilize a Reactor to remove any sensitive data, forward the desensitized request to an API, and finally respond to the originator. For this guide, we will be using the following scenario: . | We will accept card data via Basis Theory’s API from one of our partners. The request body will be as follows: { \"merchantAccount\": \"TestMerchant\", \"card\": { \"expiryMonth\": \"8\", \"expiryYear\": \"2018\", \"holderName\": \"Test\", \"number\": \"4111111111111111\" } } . | We will tokenize the credit card number | We will forward the request with the new tokenized card to https://httpbin.org/post (this can be replaced by your API) | Once https://httpbin.org/post responds, this response will become the response to our partner’s original call. | . | 1. Create a new Management Application | 2. Create a Reactor Formula to handle the inbound request | 3. Create a new Application | 4. Create a new Reactor | 5. Create a new Proxy | 6. Create a new Application for our partner | 7. Call the new Proxy | . ",
    "url": "https://developers.basistheory.com/guides/collect-cards-with-proxies/",
    "relUrl": "/guides/collect-cards-with-proxies/"
  },"16": {
    "doc": "Collect and Use Credit Cards with Proxies",
    "title": "1. Create a new Management Application",
    "content": "This new management Application will be used to create new Reactor Formulas, Reactors, Applications, and the Proxy. To enable this configuration, we will configure the Application with the following settings: . | Name . | “Setup Proxy” | . | Permissions . | application:create | reactor:create | proxy:create | . | . You can use this link to pre-fill the Create Application form in our Portal. Make sure you remember the key of this new Application, you’ll use this in the following Steps. ",
    "url": "https://developers.basistheory.com/guides/collect-cards-with-proxies/#1-create-a-new-management-application",
    "relUrl": "/guides/collect-cards-with-proxies/#1-create-a-new-management-application"
  },"17": {
    "doc": "Collect and Use Credit Cards with Proxies",
    "title": "2. Create a Reactor Formula to handle the inbound request",
    "content": "We will first create a new Reactor Formula to tokenize the card number in the inbound request. This Reactor Formula will tokenize the card number and return a new body with the raw card number replaced with our newly created Token. We will use the following code to create our new Reactor Formula: . module.exports = async function (req) { const token = await req.bt.tokenize({ type: \"token\", data: req.args.body.card.number, containers: [\"/pci/high/\"] }); const body = { ...req.args.body, card: { ...req.args.body.card, number: token.id } } return { raw: { headers: req.args.headers, body } }; }; . Use the following curl command to create a new Reactor Formula: . curl \"https://api.basistheory.com/reactor-formulas\" \\ -H \"BT-API-KEY: &lt;API Key from Step 1&gt;\" \\ -H \"Content-Type: application/json\" \\ -X \"POST\" \\ -d '{ \"type\": \"private\", \"status\": \"verified\", \"name\": \"Partner Proxy Formula\", \"description\": \"Used to tokenized cards on the way to /payments\", \"icon\": \"data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==\", \"code\": \"module.exports = async function (req) {\\r\\n const token = await req.bt.tokenize({\\r\\n\\t type: \\\"token\\\",\\r\\n\\t data: req.args.body.card.number,\\r\\n\\t\\tcontainers: [\\\"/pci/high/\\\"]\\r\\n\\t});\\r\\n \\r\\n\\tconst body = {\\r\\n\\t\\t...req.args.body,\\r\\n card: {\\r\\n ...req.args.body.card,\\r\\n number: token.id\\r\\n }\\r\\n\\t}\\r\\n\\r\\n return {\\r\\n\\t\\traw: {\\r\\n\\t\\t\\theaders: req.args.headers,\\r\\n\\t\\t\\tbody\\r\\n\\t\\t}\\r\\n\\t};\\r\\n};\", \"configuration\": [], \"request_parameters\": [] }' . Make sure you remember the id of this new Reactor Formula, you’ll use this in Step 3. ",
    "url": "https://developers.basistheory.com/guides/collect-cards-with-proxies/#2-create-a-reactor-formula-to-handle-the-inbound-request",
    "relUrl": "/guides/collect-cards-with-proxies/#2-create-a-reactor-formula-to-handle-the-inbound-request"
  },"18": {
    "doc": "Collect and Use Credit Cards with Proxies",
    "title": "3. Create a new Application",
    "content": "This Application will be used by your Reactor to grant the injected bt npm module instance access to create new tokens in the /pci/ container. Create a new Application with the following settings: . | Name . | Create and Use Reactors Application | . | Type . | Private | . | Permissions . | token:create | token:use | . | . Click here to create a new Application or you can make the following request with your Management API Key from Step 1: . curl \"https://api.basistheory.com/applications\" \\ -H \"BT-API-KEY: &lt;API Key from Step 1&gt;\" \\ -H \"Content-Type: application/json\" \\ -X \"POST\" \\ -d '{ \"name\": \"Create and Use Reactors\", \"type\": \"private\", \"permissions\": [ \"token:create\", \"token:use\" ] }' . Make sure you remember the id of this new Application, you’ll use this in Step 4. When creating the Application through the Portal, you can find the Application id in the last part of the URL path when viewing details for the Application. ",
    "url": "https://developers.basistheory.com/guides/collect-cards-with-proxies/#3-create-a-new-application",
    "relUrl": "/guides/collect-cards-with-proxies/#3-create-a-new-application"
  },"19": {
    "doc": "Collect and Use Credit Cards with Proxies",
    "title": "4. Create a new Reactor",
    "content": "Use the following curl command to create a new Reacotr using the Reactor Formula id we’ve created in Step 2 and the Application id created in Step 3: . curl \"https://api.basistheory.com/reactors\" \\ -H \"BT-API-KEY: &lt;API Key from Step 1&gt;\" \\ -H \"Content-Type: application/json\" \\ -X \"POST\" \\ -d '{ \"name\": \"Partner Proxy\", \"application\": { \"id\": \"&lt;Application Id from Step 3&gt;\" }, \"formula\": { \"id\": \"&lt;Reactor Formula Id from Step 2&gt;\" } }' . Make sure you remember the id of this new Reactor, you’ll use this in Step 5. ",
    "url": "https://developers.basistheory.com/guides/collect-cards-with-proxies/#4-create-a-new-reactor",
    "relUrl": "/guides/collect-cards-with-proxies/#4-create-a-new-reactor"
  },"20": {
    "doc": "Collect and Use Credit Cards with Proxies",
    "title": "5. Create a new Proxy",
    "content": "Using our newly created Reactor (from Step 4) configure a new Proxy. When created, a new key will be generated for that Proxy. When that Proxy is used it will invoke the specified Reactor and forward the output to your specified destination_url. Anything responded from your destination_url will be ultimately returned to the original caller. Use the following curl command to create a proxy: . curl \"https://api.basistheory.com/proxies\" \\ -H \"BT-API-KEY: &lt;API Key from Step 1&gt;\" \\ -H \"Content-Type: application/json\" \\ -X \"POST\" \\ -d '{ \"name\": \"Partner Proxy\", \"request_reactor_id\": \"&lt;Reactor Id from Step 4&gt;\", \"destination_url\": \"https://httpbin.org/post\" }' . Substitute the destination_url for your API whenever you’re ready to receive requests . This will respond with the following: . { \"id\": \"e3337cfe-3e50-45b9-a847-e29a50980ca5\", \"tenant_id\": \"c290ba6f-9214-4de1-8948-9f0fe2481807\", \"name\": \"Partner Proxy\", \"key\": \"e29a50980ca5\", \"request_reactor_id\": \"&lt;Reactor Id from Step 4&gt;\", \"destination_url\": \"https://httpbin.org/post\", \"require_auth\": true, ... } . Make sure you remember the key of this new Proxy, you’ll use this in Step 7. ",
    "url": "https://developers.basistheory.com/guides/collect-cards-with-proxies/#5-create-a-new-proxy",
    "relUrl": "/guides/collect-cards-with-proxies/#5-create-a-new-proxy"
  },"21": {
    "doc": "Collect and Use Credit Cards with Proxies",
    "title": "6. Create a new Application for our partner",
    "content": "By default, all Proxies require auth. In order to grant access to call a Proxy, we’ll need to create a new Application with permissions to use this Proxy. Create a new Application with the following settings: . | Name . | Partner Application | . | Type . | Private | . | Permissions . | token:use | . | . Click here to create a new Application or you can make the following request with your Management API Key from Step 1: . curl \"https://api.basistheory.com/applications\" \\ -H \"BT-API-KEY: &lt;API Key from Step 1&gt;\" \\ -H \"Content-Type: application/json\" \\ -X \"POST\" \\ -d '{ \"name\": \"Partner Application\", \"type\": \"private\", \"permissions\": [ \"token:use\" ] }' . Make sure you remember the key of this new Application, you’ll use this in Step 7. ",
    "url": "https://developers.basistheory.com/guides/collect-cards-with-proxies/#6-create-a-new-application-for-our-partner",
    "relUrl": "/guides/collect-cards-with-proxies/#6-create-a-new-application-for-our-partner"
  },"22": {
    "doc": "Collect and Use Credit Cards with Proxies",
    "title": "7. Call the new Proxy",
    "content": "Using the new Proxy endpoint our partner can call this endpoint: . curl \"https://api.basistheory.com/proxy\" \\ -H \"BT-API-KEY: &lt;API Key from Step 6&gt;\" \\ -H \"BT-PROXY-KEY: &lt;Proxy Key from Step 5&gt;\" \\ -H \"Content-Type: application/json\" \\ -X \"POST\" \\ -d '{ \"merchantAccount\": \"TestMerchant\", \"card\": { \"expiryMonth\": \"8\", \"expiryYear\": \"2018\", \"holderName\": \"Test\", \"number\": \"4111111111111111\" } }' . The request to the destination_url will look like the following: . { \"merchantAccount\": \"TestMerchant\", \"card\": { \"expiryMonth\": \"8\", \"expiryYear\": \"2018\", \"holderName\": \"Test\", \"number\": \"1767a42d-0b1a-400d-8f20-7e35daaf2547\" } } . 🎉 Success! . After placing this call, the endpoint at https://httpbin.org/post will be called and the curl command from Step 6 will have the response from this endpoint. ",
    "url": "https://developers.basistheory.com/guides/collect-cards-with-proxies/#7-call-the-new-proxy",
    "relUrl": "/guides/collect-cards-with-proxies/#7-call-the-new-proxy"
  },"23": {
    "doc": "Collect Customer Data (PII) with JavaScript",
    "title": "Collect Customer Data (PII) with JavaScript",
    "content": "Basis Theory is built to handle any payload of data you can serialize. The following guide shows how to collect and secure Personal Identifiable Information data in 3 simple steps, keeping it safe and secure. Using React? Check out the Collect Customer Data (PII) with React Guide. | Tokenize your PII data in the browser . | Collect data on your frontend application | Tokenize the data with our SDK. | . | Retrieve your Token on your server | . ",
    "url": "https://developers.basistheory.com/guides/collect-pii-js/",
    "relUrl": "/guides/collect-pii-js/"
  },"24": {
    "doc": "Collect Customer Data (PII) with JavaScript",
    "title": "Tokenize your PII data in the browser",
    "content": "To start, you’ll need a Public Application with the token:create permission to the /pii/ container. Click here to create one. To get started, you’ll need to first start creating tokens out of your customer data. You are able to use our basistheory-js SDK to take values from your frontend and begin tokenizing the data. (You’re also able to create these tokens from your server-side by using the same tokenization code.) . Collect data on your frontend application . &lt;div id=\"customer_form\"&gt; &lt;div class=\"row\"&gt; &lt;label for=\"name\"&gt;Name&lt;/label&gt; &lt;input id=\"name\" placeholder=\"Jane Doe\" /&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;label for=\"phone\"&gt;Phone&lt;/label&gt; &lt;input id=\"phone\" placeholder=\"+55 (55) 55555-5555\" /&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;label for=\"ssn\"&gt;\"Gov't Id\"&lt;/label&gt; &lt;input id=\"ssn\" placeholder=\"555-55-5555\" /&gt; &lt;/div&gt; &lt;button id=\"submit_button\" type=\"button\" onclick=\"submit()\"&gt; Submit &lt;/button&gt; &lt;/div&gt; . Tokenize the data with our SDK. async function submit() { const name = document.getElementById(\"name\").value; const ssn = document.getElementById(\"ssn\").value; const masked_ssn = ssn.substring(ssn.length - 4) const phone = document.getElementById(\"phone\").value; const bt = await BasisTheory.init('your_api_key'); const token = await bt.tokens.create({ type: 'token', data: { name, ssn, phone }, containers: [\"/pii/\"] }); } . In the previous example, we are creating the token within the /pii/ container to classify it as PII data. If we omit the containers property from the request, the token would be placed in the /general/high/ container by default. ",
    "url": "https://developers.basistheory.com/guides/collect-pii-js/#tokenize-your-pii-data-in-the-browser",
    "relUrl": "/guides/collect-pii-js/#tokenize-your-pii-data-in-the-browser"
  },"25": {
    "doc": "Collect Customer Data (PII) with JavaScript",
    "title": "Retrieve your Token on your server",
    "content": "To start, you’ll need a Private Application with the token:read permission to the /pii/ container. Click here to create one. We suggest only reading Token data via your server-side code, this will ensure your private application keys are never visible in the browser and your sensitive customer data is only revealed to your servers. const bt = new BasisTheory(); await bt.init(SERVER_KEY); const token = await bt.tokens.retrieve(customerTokenId); return token; . ",
    "url": "https://developers.basistheory.com/guides/collect-pii-js/#retrieve-your-token-on-your-server",
    "relUrl": "/guides/collect-pii-js/#retrieve-your-token-on-your-server"
  },"26": {
    "doc": "Collect Customer Data (PII) with JavaScript",
    "title": "See it in action",
    "content": "See a sample and the code that drives it below. Want to experience the sandbox yourself? Check it out here. ",
    "url": "https://developers.basistheory.com/guides/collect-pii-js/#see-it-in-action",
    "relUrl": "/guides/collect-pii-js/#see-it-in-action"
  },"27": {
    "doc": "Collect Customer Data (PII) with React",
    "title": "Collect Customer Data (PII) with React",
    "content": "Basis Theory is built to handle any payload of data you can serialize. Once you’ve completed this guide, you’ll know how to use our React package to of how to collect and secure your customer’s PII (Personally Identifiable Information) data in 3 simple steps with our Elements, keeping it safe and secure. If you’d like to follow along with this guide from scratch, we suggest creating a new React sandbox using codesandbox.io and getting started from there! Want to jump right into our sample app? Find it here! . ",
    "url": "https://developers.basistheory.com/guides/collect-pii-react/",
    "relUrl": "/guides/collect-pii-react/"
  },"28": {
    "doc": "Collect Customer Data (PII) with React",
    "title": "Let’s code",
    "content": "To start, you’ll need a Public Application with the token:create permission to the /pii/ container. Click here to create one. Install our dedicated React package: . npm install --save @basis-theory/basis-theory-react . Initialize the Basis Theory SDK passing the API Key to the useBasisTheory hook and wrap your App contents with a BasisTheoryProvider: . import { useBasisTheory, BasisTheoryProvider, } from '@basis-theory/basis-theory-react'; function App() { const { bt } = useBasisTheory(ELEMENTS_API_KEY, { elements: true, }); return ( &lt;BasisTheoryProvider bt={bt}&gt; &lt;!-- rest of app code goes here --&gt; &lt;/BasisTheoryProvider&gt; ); } export default App; . Create a RegistrationForm component and add it somewhere in your App content. Create two refs that will be used to store the underlying elements instances. Declare two TextElement tags inside it, one for the “Full Name”, and the other for the “Social Security Number”; then call the tokenize method passing the current elements instance from the refs: . import { useRef } from 'react'; import { TextElement, useBasisTheory } from '@basis-theory/basis-theory-react'; export const RegistrationForm = () =&gt; { const { bt } = useBasisTheory(); const fullNameRef = useRef(null); const ssnRef = useRef(null); const submit = async () =&gt; { try { const response = await bt.tokenize({ fullName: fullNameRef.current, ssn: { type: 'social_security_number', data: ssnRef.current, }, }); } catch (error) { console.error(error); } }; return ( &lt;&gt; &lt;TextElement id=\"fullName\" ref={fullNameRef} /&gt; &lt;TextElement id=\"ssn\" ref={ssnRef} /&gt; &lt;button id=\"submit_button\" type=\"button\" onClick={submit} &gt; Submit &lt;/button&gt; &lt;/&gt; ); }; . Success! 🎉 Your application is now collecting and storing PII in Basis Theory platform. ",
    "url": "https://developers.basistheory.com/guides/collect-pii-react/#lets-code",
    "relUrl": "/guides/collect-pii-react/#lets-code"
  },"29": {
    "doc": "Collect Customer Data (PII) with React",
    "title": "Next steps",
    "content": "You can further customize the TextElement props to best suit your needs. The Tokens you’ve created from your frontend application can be used in a variety of ways from within your system, check out a few of those below: . | Fetched later in your servers, using a Private Application Key (click here to create one) to call Get a Token API; | Used to call on of our Reactors to process that data. Some use cases are: . | Integrating with third party KYC platforms, such as Alloy; | Pull credit reports for your customers without touching their data; | Send e-mails or instant messages to communication channels; | Pull background checks; | . | Make a third party API request with the raw data through our Proxy. | . ",
    "url": "https://developers.basistheory.com/guides/collect-pii-react/#next-steps",
    "relUrl": "/guides/collect-pii-react/#next-steps"
  },"30": {
    "doc": "Collect Customer Data (PII) with React",
    "title": "See it in action",
    "content": "The example below uses a few of the Element’s user experience features to ensure the best experience to your customers: . | Pass a mask to the ssn field, restricting user input to digits only and formatting the output; | Use a transform option in the ssn field to strip out dash ‘-‘ characters from the tokenized data; | Disable the “Submit” &lt;button&gt; while the fullName field is empty or the ssn field is not complete, by listening to their onChange event; | Disable both inputs and the “Submit” button during the tokenization request inside the submit function; | Display the full stringified tokens response; | Log any tokenization errors to the console; | . See it running and the code that drives it below. Want to experience the sandbox yourself? Check it out here. ",
    "url": "https://developers.basistheory.com/guides/collect-pii-react/#see-it-in-action",
    "relUrl": "/guides/collect-pii-react/#see-it-in-action"
  },"31": {
    "doc": "Encrypt U.S. Banks in your applications",
    "title": "Encrypt U.S Banks in your applications",
    "content": "This guide will quickly enable you to be compliant with new Nacha encryption rules. Your customer’s bank information is as sensitive as their credit card data, and needs to be stored with the same care. Encrypting this data takes a strong encryption pattern, including a KMS, key rotation, multiple encryption keys, access controls, and so much more. In this guide, we will show you how to take an existing API and use Basis Theory to safely store the bank data while retaining the exact application functionality. If you’d like to follow along with this guide jump right into the code - Find it here! . | The existing application . | package.json | app.js | . | Install basis-theory-js | Initialize basis-theory-js | Secure your bank data | Retrieve and return the raw data | Optional: Add an endpoint to return masked data | Wrap up | Watch the video guide | . ",
    "url": "https://developers.basistheory.com/guides/encrypt-us-banks-in-your-applications/#encrypt-us-banks-in-your-applications",
    "relUrl": "/guides/encrypt-us-banks-in-your-applications/#encrypt-us-banks-in-your-applications"
  },"32": {
    "doc": "Encrypt U.S. Banks in your applications",
    "title": "The existing application",
    "content": "Below is an existing Node.js application that is currently storing bank data in memory, this will be used as our foundation as we update to more securely store the bank data. (Note: this is only to simplify the guide, the same process will work when storing in a database). package.json . Our simple package.json, only has two dependencies to start. express allows us to quickly create an HTTP API, and nodemon allows us to have our nodejs application restart automatically. { \"name\": \"bank-data\", \"description\": \"\", \"version\": \"1.0.0\", \"author\": \"Basis Theory\", \"scripts\": { \"start\": \"nodemon app.js\" }, \"dependencies\": { \"express\": \"^4.17.1\" }, \"devDependencies\": { \"nodemon\": \"1.18.4\" } } . app.js . Our application simply allows a U.S. Bank Account to be sent into the system, stored in memory, and retrieved back. (Even though our example doesn’t show them, your systems will most likely have authentication, databases, etc.) . const express = require('express') const app = express() app.use(express.json()); const port = 3000 // simple storage for this example, this is most likely a DB in your system let account = {}; // returning the raw bank information app.get('/get', async (req, res) =&gt; { res.send(account) }) // storing the bank information app.post('/create', async (req, res) =&gt; { const {accountNumber, routingNumber} = req.body; account = {accountNumber, routingNumber}; res.send() }) // starting up your API server app.listen(port, async () =&gt; { console.log(`Example app listening at http://localhost:${port}`) }) . ",
    "url": "https://developers.basistheory.com/guides/encrypt-us-banks-in-your-applications/#the-existing-application",
    "relUrl": "/guides/encrypt-us-banks-in-your-applications/#the-existing-application"
  },"33": {
    "doc": "Encrypt U.S. Banks in your applications",
    "title": "Install basis-theory-js",
    "content": "To start, you’ll need a new Private Application with the token:create and token:read permissions granted on the /bank/ container. Click here to create one. First, you’ll need to install the basis-theory-js npm module . npm install @basis-theory/basis-theory-js --save . ",
    "url": "https://developers.basistheory.com/guides/encrypt-us-banks-in-your-applications/#install-basis-theory-js",
    "relUrl": "/guides/encrypt-us-banks-in-your-applications/#install-basis-theory-js"
  },"34": {
    "doc": "Encrypt U.S. Banks in your applications",
    "title": "Initialize basis-theory-js",
    "content": "Next, we will need to initialize an instance of BasisTheory and store a reference to be used later: . let basisTheory; // top of your file // ... app.listen(port, async () =&gt; { basisTheory = await new BasisTheory().init(\"&lt;YOUR API KEY&gt;\"); console.log(`Example app listening at http://localhost:${port}`) }) . ",
    "url": "https://developers.basistheory.com/guides/encrypt-us-banks-in-your-applications/#initialize-basis-theory-js",
    "relUrl": "/guides/encrypt-us-banks-in-your-applications/#initialize-basis-theory-js"
  },"35": {
    "doc": "Encrypt U.S. Banks in your applications",
    "title": "Secure your bank data",
    "content": "With your initialized BasisTheory, your system can securely store bank information with Basis Theory and store a reference to the data within your database: . app.post('/create', async (req, res) =&gt; { const {accountNumber, routingNumber} = req.body; const bankToken = await basisTheory.tokens.create({ type: 'bank', data: { routingNumber, accountNumber } }); account = bankToken; res.send(\"Bank token created \\n\"); }) . To test that you’re now storing this information, you can run this curl command: . curl --location --request POST 'http://127.0.0.1:3000/create' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"routingNumber\": \"021000021\", \"accountNumber\": \"1234567891099\" }' . ",
    "url": "https://developers.basistheory.com/guides/encrypt-us-banks-in-your-applications/#secure-your-bank-data",
    "relUrl": "/guides/encrypt-us-banks-in-your-applications/#secure-your-bank-data"
  },"36": {
    "doc": "Encrypt U.S. Banks in your applications",
    "title": "Retrieve and return the raw data",
    "content": "After we’ve stored the information with Basis Theory, we will only be storing a reference to the raw bank account information. With that in mind, we will alter our /get endpoint to retrieve the raw bank account data from Basis Theory. app.get('/get', async (req, res) =&gt; { if (!account) { return res.status(404).send(); } const bankToken = await basisTheory.tokens.retrieve(account.id); return res.send(JSON.stringify(bankToken.data) + \"\\n\"); }) . To test you’re retrieving the raw data from your updated endpoint: . (keep in mind: every time the sample app restarts you’ll need to call /create) . curl --location --request GET 'http://127.0.0.1:3000/get' /// { \"routingNumber\": \"021000021\", \"accountNumber\": \"1234567891099\" } . Success! You are now securely storing your data with Basis Theory (who will manage the encryption and keep the data safe on your behalf)! . ",
    "url": "https://developers.basistheory.com/guides/encrypt-us-banks-in-your-applications/#retrieve-and-return-the-raw-data",
    "relUrl": "/guides/encrypt-us-banks-in-your-applications/#retrieve-and-return-the-raw-data"
  },"37": {
    "doc": "Encrypt U.S. Banks in your applications",
    "title": "Optional: Add an endpoint to return masked data",
    "content": "Your system may now be safely storing bank information, but how do you make your systems even safer? . Basis Theory by default returns a tokenId and masked bank information back to your system when creating a bank token, so you’re able to store and use this non-sensitive data while letting Basis Theory hold the raw sensitive data. Storing tokenIds or presenting masks to end users allows your systems to ONLY have direct access to non-sensitive data! The raw decrypted bank account data can be retrieved from Basis Theory only when you absolutely need it and only by applications that are explicitly granted access to this raw data. Below is a new endpoint, showing how you can return the masked data stored in your system: . app.get('/get_mask', (req, res) =&gt; { res.send(JSON.stringify(account.data) + \"\\n\"); }) . To test you’re retrieving the masked data from your new endpoint: . (keep in mind: every time the sample app restarts you’ll need to call /create) . curl --location --request GET 'http://127.0.0.1:3000/get_mask' /// { \"routingNumber\": \"021000021\", \"accountNumber\": \"XXXXXXXXX1099\" } . ",
    "url": "https://developers.basistheory.com/guides/encrypt-us-banks-in-your-applications/#optional-add-an-endpoint-to-return-masked-data",
    "relUrl": "/guides/encrypt-us-banks-in-your-applications/#optional-add-an-endpoint-to-return-masked-data"
  },"38": {
    "doc": "Encrypt U.S. Banks in your applications",
    "title": "Wrap up",
    "content": "You’re now able to quickly update your existing systems to encrypt and safely store bank data with Basis Theory, you may now be asking “what’s next?” . | Use our Serverless Reactors to create an ACH file (if you’re looking to do this, reach out!) | Never have your systems touch bank data again | Interact with any other banking service you can imagine (e.g. Dwolla, Plaid, etc.) | Easily encrypt your existing bank data | . ",
    "url": "https://developers.basistheory.com/guides/encrypt-us-banks-in-your-applications/#wrap-up",
    "relUrl": "/guides/encrypt-us-banks-in-your-applications/#wrap-up"
  },"39": {
    "doc": "Encrypt U.S. Banks in your applications",
    "title": "See it in action",
    "content": "Want to see the final result? Find it here! . ",
    "url": "https://developers.basistheory.com/guides/encrypt-us-banks-in-your-applications/#see-it-in-action",
    "relUrl": "/guides/encrypt-us-banks-in-your-applications/#see-it-in-action"
  },"40": {
    "doc": "Encrypt U.S. Banks in your applications",
    "title": "Watch the video guide",
    "content": " ",
    "url": "https://developers.basistheory.com/guides/encrypt-us-banks-in-your-applications/#watch-the-video-guide",
    "relUrl": "/guides/encrypt-us-banks-in-your-applications/#watch-the-video-guide"
  },"41": {
    "doc": "Encrypt U.S. Banks in your applications",
    "title": "Encrypt U.S. Banks in your applications",
    "content": " ",
    "url": "https://developers.basistheory.com/guides/encrypt-us-banks-in-your-applications/",
    "relUrl": "/guides/encrypt-us-banks-in-your-applications/"
  },"42": {
    "doc": "Quickstart home",
    "title": "Getting Started",
    "content": "Step-by-step guides to securing data with Basis Theory. Once you’ve completed one of these tutorials, you’ll have a foundational understanding of how to secure your data with Basis Theory allowing you to no longer worry about the underlying storage or encryption of the data. If you are already familiar with Basis Theory and our platform in general, our guide on How to send Token data via HTTP or Collecting payments with Elements may be a better place to start. NodeJS 10 min Curl 10 min Ruby 10 min .NET 10 min Python 10 min Java 10 min Go 10 min . ",
    "url": "https://developers.basistheory.com/getting-started",
    "relUrl": "/getting-started"
  },"43": {
    "doc": "Quickstart home",
    "title": "Quickstart home",
    "content": "Getting Started with Ruby, Python, .NET, Java, C#, cURL, NodeJS . ",
    "url": "https://developers.basistheory.com/getting-started",
    "relUrl": "/getting-started"
  },"44": {
    "doc": "Developers Home",
    "title": "Documentation",
    "content": "Explore our APIs, SDKs, and all of the tools you need to make your sensitive data more secure and usable. Quickstarts In just a few steps, learn how to secure and use your data with Basis Theory's tokenization. Quick start 10 min Concepts 5 min Tokens Use Tokens to secure and share your sensitive data. 5 min Access Controls Configure your environment and manage access to your Tokens. 5 min Proxy Send HTTP requests with tokenized data without touching it. Guides Secure Your Data Learn how to easily tokenize your data on any platform. | Collect Credit Cards with React 5m | Encrypt U.S Banks in your applications 10m | Style elements to match your brand 10m | Collect Customer Data (PII) with JS 5m | Use Your Data Learn how to integrate and make the most out of tokenized data. | Use Token Data in HTTP Requests 10m | Use U.S. Bank Accounts 10m | Collect and Charge Credit Cards with JS 15m | Use Token Data in Reactors 10m | Reveal Card Data w/ React10m | Reference API Reference Use our API's and SDK's to interact with your Tokens. Elements Secure data from your frontend without touching it. Expressions Learn about the expression language supported throughout the Basis Theory API. ",
    "url": "https://developers.basistheory.com/",
    "relUrl": "/"
  },"45": {
    "doc": "Developers Home",
    "title": "Developers Home",
    "content": "Basis Theory Overview . ",
    "url": "https://developers.basistheory.com/",
    "relUrl": "/"
  },"46": {
    "doc": "Basis Theory Labs",
    "title": "Basis Theory Labs",
    "content": "Sample apps, demos and innovation powered by Basis Theory. Basis Theory enables you to tokenize anything, anywhere. Here you can get a sneak peek of Basis Theory's potential by looking at some interesting usages we built for you! Securing data is a must, and whether it is in the context of infrastructure as code, secret sharing, content management systems or anything else you can imagine, we have you covered. Ansible Lookup Plugin Simple Ansible Lookup Plugin to retrieve secrets from Basis Theory's REST API | Centralizing Operational Secrets with Ansible | Code Sample | Sample App | ORM Tokenization - Entity Framework Example application to tokenize sensitive data with Entity Framework utilizing Basis Theory's REST API. | Secure Sensitive Data in Five Lines of Code | Code Sample | Sample App | Send Secrets Securely A Basis Theory Lab that enables users to securely share passwords, credentials, or any other sensitive data with another person. | Send Secrets Securely | See it live | Code Sample | Sample App | . ",
    "url": "https://developers.basistheory.com/labs",
    "relUrl": "/labs"
  },"47": {
    "doc": "Basis Theory Labs",
    "title": "Basis Theory Labs",
    "content": "Basis Theory Labs . ",
    "url": "https://developers.basistheory.com/labs",
    "relUrl": "/labs"
  },"48": {
    "doc": "Manage Applications with Terraform",
    "title": "Manage Applications with Terraform",
    "content": "Terraform is a popular and powerful tool that enables you to version your infrastructure as code. In this guide, we’ll walk you through setting up Terraform to manage your resources locally within Basis Theory. By the end of this guide, you will have created an Application under your tenant using Terraform, and you will have an Application key available for you to use. | Install Terraform | Set up Terraform configuration . | Set up the basistheory provider | Set up the basistheory_application resource | Set up the output for your Application key | . | Executing Terraform | Using Terraform to manage other Basis Theory resources | . To start, you’ll need a new Management Application with application:create, application:read, application:update, and application:delete permissions. Click here to create one. ",
    "url": "https://developers.basistheory.com/guides/manage-applications-with-terraform/",
    "relUrl": "/guides/manage-applications-with-terraform/"
  },"49": {
    "doc": "Manage Applications with Terraform",
    "title": "Install Terraform",
    "content": "To achieve the following steps, you must have the Terraform CLI installed locally or wherever you’re planning on running your configuration. The best guide for installing Terraform can be found on their own website here. ",
    "url": "https://developers.basistheory.com/guides/manage-applications-with-terraform/#install-terraform",
    "relUrl": "/guides/manage-applications-with-terraform/#install-terraform"
  },"50": {
    "doc": "Manage Applications with Terraform",
    "title": "Set up Terraform configuration",
    "content": "Let’s set up the Terraform configuration you’ll need for creating an Application and exporting the Application key you’ll need to interact with other Basis Theory resources. Set up the basistheory provider . Firstly, you’ll need to configure the terraform configuration block in a main.tf file. Let’s add a source for where to pull down our Terraform provider, and pin the version as well. View the latest version available here. terraform { required_providers { basistheory = { source = \"basis-theory/basistheory\" version = \"&gt;= 0.1.3\" } } } . Now you’ll need to define some details for the provider. To start with you can define the API URL, API key, and client timeout within the basistheory provider. provider \"basistheory\" { api_url = \"https://api.basistheory.com\" api_key = \"&lt;YOUR_API_KEY_HERE&gt;\" client_timeout = 5 } . Another configuration option is to just set the API key through setting a BASISTHEORY_API_KEY environment variable. This leaves you with optionally setting the API URL and client timeout through BASISTHEORY_API_URL and BASISTHEORY_CLIENT_TIMEOUT environment variables, respectively. These don’t need to be explicitly set since the API URL defaults to https://api.basistheory.com and the client timeout defaults to 15 seconds. So the most minimal main.tf file can look like this: . terraform { required_providers { basistheory = { source = \"basis-theory/basistheory\" version = \"&gt;= 0.1.3\" } } } provider \"basistheory\" { } . Set up the basistheory_application resource . Typically, resources are set up in a different file from the provider and terraform block. So let’s create an application.tf file with the configuration for our Application. Feel free to modify the following configuration for your use case: . resource \"basistheory_application\" \"my_application\" { name = \"My Application\" type = \"private\" permissions = [ \"token:create\", \"token:read\", \"token:search\", ] } . Set up the output for your Application key . To make use of the Application you create, you’ll need to extract the key. Defining output blocks make data about your resources available for use within the command line. Define the ouput block in a new output.tf file with the contents below: . output \"my_application_key\" { value = basistheory_application.my_application.key description = \"My Application key\" sensitive = true } . ",
    "url": "https://developers.basistheory.com/guides/manage-applications-with-terraform/#set-up-terraform-configuration",
    "relUrl": "/guides/manage-applications-with-terraform/#set-up-terraform-configuration"
  },"51": {
    "doc": "Manage Applications with Terraform",
    "title": "Executing Terraform",
    "content": "Now that our configuration is set up, it’s time to execute Terraform commands to get these resources created. The first step in managing any resources via Terraform, is to initialize your directory with your configuration. There are many things that occur when initializing Terraform, one of which is downloading the basistheory provider from the public Terraform registry. Let’s run the following terraform commands within the same directory containing your configuration. terraform init . A prudent step to ensure you have a valid configuration is to run basistheory’s provider validations against your current configuration. This command uses local resources to validate against the downloaded provider and does not talk to any remote resources. If your configuration is valid the command prints out Success! The configuration is valid.. terraform validate . Finally, you can apply the configuration using the apply command. apply will output a plan Terraform intends to execute and waits for your confirmation. This plan contains differences between your current configuration and your current Terraform state. After reviewing the plan, type yes to create your Application within Basis Theory. terraform apply . If all was successful, Terraform should output that 1 resource was successfully added. If you made it this far, pat yourself on the back! 🎉 You’ve successfully created an Application via Terraform! You can view your new Application within the Portal. Now in order to use the Application API Key for curl commands, for example, you’ll need to export the key that was just created. You can do this by executing the output command below: . The following command will print the sensitive Application key to the terminal. terraform output -raw my_application_key . You can follow our quickstart with curl guide and skip to step 3 to create tokens with your Application API key output. ",
    "url": "https://developers.basistheory.com/guides/manage-applications-with-terraform/#executing-terraform",
    "relUrl": "/guides/manage-applications-with-terraform/#executing-terraform"
  },"52": {
    "doc": "Manage Applications with Terraform",
    "title": "Using Terraform to manage other Basis Theory resources",
    "content": "If you’d like to manage other Basis Theory resources via Terraform, take a look at the other docs we’ve made available in the Terraform provider docs. ",
    "url": "https://developers.basistheory.com/guides/manage-applications-with-terraform/#using-terraform-to-manage-other-basis-theory-resources",
    "relUrl": "/guides/manage-applications-with-terraform/#using-terraform-to-manage-other-basis-theory-resources"
  },"53": {
    "doc": "Manage Reactor Formulas with Terraform",
    "title": "Manage Reactor Formulas with Terraform",
    "content": "Terraform is a popular and powerful tool that enables you to version your infrastructure as code. In this guide, we’ll walk you through setting up Terraform to manage your resources locally within Basis Theory. By the end of this guide, you will have created a Reactor Formula under your Tenant using Terraform. | Install Terraform | Set up Terraform configuration . | Set up the basistheory provider | Set up the basistheory_reactor_formula resource | Set up a basistheory_reactor resource from the Reactor Formula | . | Executing Terraform | Using Terraform to manage other Basis Theory resources | . To start, you’ll need a new Management Application with reactor:create, reactor:read, reactor:update, and reactor:delete permissions. Click here to create one. ",
    "url": "https://developers.basistheory.com/guides/manage-reactor-formulas-with-terraform/",
    "relUrl": "/guides/manage-reactor-formulas-with-terraform/"
  },"54": {
    "doc": "Manage Reactor Formulas with Terraform",
    "title": "Install Terraform",
    "content": "To achieve the following steps, you must have the Terraform CLI installed locally or wherever you’re planning on running your configuration. The best guide for installing Terraform can be found on their own website here. ",
    "url": "https://developers.basistheory.com/guides/manage-reactor-formulas-with-terraform/#install-terraform",
    "relUrl": "/guides/manage-reactor-formulas-with-terraform/#install-terraform"
  },"55": {
    "doc": "Manage Reactor Formulas with Terraform",
    "title": "Set up Terraform configuration",
    "content": "Let’s set up the Terraform configuration you’ll need for creating a Reactor Formula. Set up the basistheory provider . Firstly, you’ll need to configure the terraform and provider configuration blocks in a main.tf file. Let’s add the configuration for the provider source and provider configuration. You can find the latest versions available and other configuration options in the provider documentation here. terraform { required_providers { basistheory = { source = \"basis-theory/basistheory\" version = \"&gt;= 0.1.3\" } } } provider \"basistheory\" { api_key = \"&lt;YOUR_API_KEY_HERE&gt;\" } . Set up the basistheory_reactor_formula resource . Typically, resources are set up in a different file outside of main.tf. Let’s create a new reactor_formula.tf file with the following configuration for our Reactor Formula. Feel free to modify the following configuration for your use case: . For more information about writing your own code for a Reactor Formula, check out our guide. resource \"basistheory_reactor_formula\" \"my_awesome_formula\" { name = \"My Awesome Reactor Formula\" description = \"Do something awesome!\" type = \"private\" icon = \"data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==\" code = &lt;&lt;-EOT module.exports = async function (req) { // Do something with `req.configuration.SERVICE_API_KEY` // Do anything here! return { raw: { foo: \"bar\" }, tokenize: {} }; }; EOT configuration { name = \"SERVICE_API_KEY\" description = \"Configuration description\" type = \"string\" } request_parameter { name = \"request_parameter_1\" description = \"Request parameter description\" type = \"string\" } request_parameter { name = \"request_parameter_2\" description = \"Request parameter description\" type = \"boolean\" optional = true } } . Set up a basistheory_reactor resource from the Reactor Formula . Next, we can create and configure a Reactor referencing the Reactor Formula ID of basistheory_reactor_formula.my_awesome_formula.id. Let’s create a new reactor.tf file with the following configuration for our Reactor Formula. Feel free to modify the following configuration for your use case: . variable \"service_api_key\" { type = string sensitive = true default = \"foo\" } resource \"basistheory_reactor\" \"my_awesome_reactor\" { name = \"My Awesome Reactor\" formula_id = basistheory_reactor_formula.my_awesome_formula.id configuration = { SERVICE_API_KEY = var.service_api_key # default value can be overridden by setting TF_VAR_service_api_key environment variable } } . ",
    "url": "https://developers.basistheory.com/guides/manage-reactor-formulas-with-terraform/#set-up-terraform-configuration",
    "relUrl": "/guides/manage-reactor-formulas-with-terraform/#set-up-terraform-configuration"
  },"56": {
    "doc": "Manage Reactor Formulas with Terraform",
    "title": "Executing Terraform",
    "content": "Now that our configuration is set up, it’s time to execute Terraform commands to create these resources within your Basis Theory Tenant. The first step in managing any resources via Terraform, is to initialize your directory with your configuration. There are many things that occur when initializing Terraform, one of which is downloading the basistheory provider from the public Terraform registry. Let’s run the following terraform commands within the same directory containing your configuration. terraform init . A prudent step to ensure you have a valid configuration is to run basistheory’s provider validations against your current configuration. This command uses local resources to validate against the downloaded provider and does not talk to any remote resources. If your configuration is valid the command prints out Success! The configuration is valid.. terraform validate . Finally, you can apply the configuration using the apply command. apply will output a plan Terraform intends to execute and waits for your confirmation. This plan contains differences between your current configuration and your current Terraform state. After reviewing the plan, type yes to create your Reactor Formula and Reactor within Basis Theory. terraform apply . If all was successful, Terraform should output that 2 resources were successfully created. If you made it this far, pat yourself on the back! 🎉 You’ve successfully created a Reactor Formula and configured a Reactor via Terraform! To find these new resources in the Basis Theory Portal, select the appropriate Tenant and then check out the available Reactor Formulas and Reactors. ",
    "url": "https://developers.basistheory.com/guides/manage-reactor-formulas-with-terraform/#executing-terraform",
    "relUrl": "/guides/manage-reactor-formulas-with-terraform/#executing-terraform"
  },"57": {
    "doc": "Manage Reactor Formulas with Terraform",
    "title": "Using Terraform to manage other Basis Theory resources",
    "content": "If you’d like to manage other Basis Theory resources via Terraform, take a look at the other docs we’ve made available in the Terraform provider docs. ",
    "url": "https://developers.basistheory.com/guides/manage-reactor-formulas-with-terraform/#using-terraform-to-manage-other-basis-theory-resources",
    "relUrl": "/guides/manage-reactor-formulas-with-terraform/#using-terraform-to-manage-other-basis-theory-resources"
  },"58": {
    "doc": "Migrating off Basis Theory",
    "title": "Migrating off Basis Theory",
    "content": "We know business goals and technical needs change over time. We get it. More importantly, we want to make sure you have what you need to move off of Basis Theory and just as quickly as we’ve helped you safely build your products and protect your data. This guide will walk you through moving your PCI compliant data to another compliant service provider and options to move all of your non-PCI data into your database or another vault. If you need help with your migration plan - please reach out. Warning: Moving your compliant data Before migrating data out of Basis Theory’s systems, you should confirm that the desired location meets all requirements for the underlying data type. For example, moving your card data off of Basis Theory will require you or your new provider to be Payments Card Institute (PCI) Level 1 compliant. ",
    "url": "https://developers.basistheory.com/guides/migrating-off-basis-theory/",
    "relUrl": "/guides/migrating-off-basis-theory/"
  },"59": {
    "doc": "Migrating off Basis Theory",
    "title": "Step 1: Create a full-access Basis Theory Application",
    "content": "To move all of your data quickly, you’ll want to create a Private Application with all permissions within the Tenant you’re looking to migrate. Keep in mind this Application will have the highest level of access to your data, so you’ll want to secure the API Key with the highest level of security possible as you migrate. Click here to create an Application with all permissions. ",
    "url": "https://developers.basistheory.com/guides/migrating-off-basis-theory/#step-1-create-a-full-access-basis-theory-application",
    "relUrl": "/guides/migrating-off-basis-theory/#step-1-create-a-full-access-basis-theory-application"
  },"60": {
    "doc": "Migrating off Basis Theory",
    "title": "Step 2: Choose a method to migrate data out of Basis Theory",
    "content": "There are three recommended ways to migrate your existing Basis Theory data to a new location. | Proxy | Export | Reactor | . Read each section carefully, as certain methods may not be ideal for certain types of data or situations. 1. Proxy . Using our Proxy is the simplest path to migrating your data to another API-based service provider. Proxy enables you to forward your tokens to a new provider without the plaintext data touching your systems. The following example provides a pattern for proxying your plaintext data to a new provider and storing your new provider’s identifiers in your database. The array of tokens is an example of data you’ve stored in your database - replace this by querying your database. import axios from 'axios'; async function migration() { const rowsFromDatabase = [ {name: 'test', ssn: 'fc88408b-d031-49c6-abd9-9e53589a6091'}, {name: 'test', ssn: 'c35f271e-0338-45fb-a036-c36a0e290ab7'}, // .. more rows of data ]; rowsFromDatabase.forEach(async (row, i) =&gt; { const token = await axios.post('https://api.basistheory.com/proxy', { value: `{{${row.ssn}}}`, format: 'UUID' }, { headers: { 'BT-PROXY-URL': '&lt;https://api.new.provider/secure&gt;', 'BT-API-KEY': 'key_here', } }); rowsFromDatabase[i].ssn = token.aliases[0].alias; }); //save rowsFromDatabase to save the raw values back into your database } . 2. Export all of your data . WARNING: For Card data (PCI), you can only export if you are PCI Level 1 compliant and have submitted your Report on Compliance to Basis Theory. Please reach out for help submitting your ROC. If you’re looking to move to another PCI Level 1 provider, please view our Proxy or Reactor solution. Depending on your situation, you may want to export your data directly into your database instead of moving directly to a new Tokenization provider. When you do this, you’ll want to consider encrypting the data you’re exporting to keep the security of your data at the same level Basis Theory has provided you. The following example shows how you can use the Retrieve a Token endpoint to pull back tokens you have stored within your database. The array of tokens is an example of data you’ve stored in your database - replace this by querying your database. import {BasisTheory} from '@basis-theory/basis-theory-js'; async function migration() { const bt = await new BasisTheory().init('key_here'); const rowsFromDatabase = [ {name: 'test', ssn: 'fc88408b-d031-49c6-abd9-9e53589a6091'}, {name: 'test', ssn: 'c35f271e-0338-45fb-a036-c36a0e290ab7'}, // .. more rows of data ]; rowsFromDatabase.forEach(async (row, i) =&gt; { const token = await bt.tokens.retrieve(row.ssn); rowsFromDatabase[i].ssn = token.data; }); //save rowsFromDatabase to save the raw values back into your database } . 3. Reactors to move your data to a new provider . If the above two examples don’t provide the flexibility you’re needing as you switch providers, you can take advantage of our Reactors. Reactors are serverless compute services allowing Node.js code (Reactor Formula) hosted in Basis Theory to be executed against your tokens completely isolated away from your existing application and systems. ",
    "url": "https://developers.basistheory.com/guides/migrating-off-basis-theory/#step-2-choose-a-method-to-migrate-data-out-of-basis-theory",
    "relUrl": "/guides/migrating-off-basis-theory/#step-2-choose-a-method-to-migrate-data-out-of-basis-theory"
  },"61": {
    "doc": "PCI Blueprint",
    "title": "PCI Blueprint",
    "content": "Payment Card Industry Data Security Standard (PCI DSS) is a set of compliance requirements that must be met to collect, store, and process cardholder data. To fully implement these requirements is both costly and time intensive. The Basis Theory PCI Blueprint will provide you with a guide to meet 95% of the compliance requirements of PCI in as little as 5 minutes. This blueprint assumes you are using a React frontend and Node.js API. The blueprint can be modified for your specific framework or language by leveraging our Vanilla JS implementation or one of our many language-specific SDKs. Don’t want to complete this guide? View the completed example application here. | Collect Credit Cards . | Install Basis Theory Package | Create a Public Application | Initialize Basis Theory Elements | Add Card Element | . | Store Cards . | Tokenize the Card | What is Happening? | . | Process Cards . | Create a Private Application | Send the Data to the Payment Service Provider | What is Happening? | . | Conclusion | . ",
    "url": "https://developers.basistheory.com/blueprints/pci/",
    "relUrl": "/blueprints/pci/"
  },"62": {
    "doc": "PCI Blueprint",
    "title": "Collect Credit Cards",
    "content": "The first step to reducing your PCI scope is to securely collect cardholder information without your application touching the data. To do this, we will leverage Basis Theory Elements. These secure form inputs for your web or mobile application collect sensitive cardholder data without directly interacting with the values. Install Basis Theory Package . Install the Basis Theory React package within your application using your package manager: . npm install --save @basis-theory/basis-theory-react # or yarn add @basis-theory/basis-theory-react . Create a Public Application . To securely collect cardholder data, you’ll need a Public Application using our PCI compliant template Collect PCI Data. Click here to create one. This will create a PCI-compliant application with the following Access Controls: . | Permissions: token:create, token:update | Containers: /pci/ | Transform: mask | . Copy the API Key to be used in the next step. Initialize Basis Theory Elements . Let’s create a new Card Form component. In a terminal in the same directory as your App component, type: . touch card-form.js . In your editor, update your App component with the following code, replacing PUBLIC_API_KEY with the API Key from the previous step: . import { useBasisTheory, BasisTheoryProvider } from '@basis-theory/basis-theory-react'; import { CardForm } from './card-form'; export default function App() { const { bt } = useBasisTheory('PUBLIC_API_KEY', { elements: true }); return ( &lt;BasisTheoryProvider bt={bt}&gt; &lt;CardForm /&gt; &lt;/BasisTheoryProvider&gt; ); } . Next, add the following code to your new Card Form component: . import { useBasisTheory } from '@basis-theory/basis-theory-react'; export const CardForm = () =&gt; { const { bt } = useBasisTheory(); const submit = async () =&gt; {}; return ( &lt;form onSubmit={submit}&gt; &lt;button type=\"button\" onClick={submit} &gt; Submit &lt;/button&gt; &lt;/form&gt; ); } . This will initialize Basis Theory JS and add your new card form. Add Card Element . Now, we need to add a CardElement component to our form. This Element type renders a single line containing input fields to capture the card number, expiration date, and CVC. Add the CardElement to our inputs: . import { useBasisTheory, CardElement } from '@basis-theory/basis-theory-react'; . And inside of our &lt;form&gt; tag, add the following code: . &lt;CardElement id=\"card\" /&gt; . Your card component should now look like this: . import { useBasisTheory, CardElement } from '@basis-theory/basis-theory-react'; export const CardForm = () =&gt; { const { bt } = useBasisTheory(); const submit = async () =&gt; {}; return ( &lt;form onSubmit={submit}&gt; &lt;CardElement id=\"card\" /&gt; &lt;button type=\"button\" onClick={submit} &gt; Submit &lt;/button&gt; &lt;/form&gt; ); } . You can fully customize the look and feel to match your existing site and even listen to common events on all Elements components. ",
    "url": "https://developers.basistheory.com/blueprints/pci/#collect-credit-cards",
    "relUrl": "/blueprints/pci/#collect-credit-cards"
  },"63": {
    "doc": "PCI Blueprint",
    "title": "Store Cards",
    "content": "Now that we have securely captured the card information, we need to securely store the card. To do this, we will tokenize the data with Basis Theory. Basis Theory handles all of the secure encryption and storage of the cardholder data and returns a non-sensitive token identifier that can be stored in your database. Tokenize the Card . Inside of your CardForm, we will update the submit function to tokenize the card using the PCI-compliant card Token Type: . const submit = async () =&gt; { // Tokenize card with Basis Theory const token = await bt.tokenize({ type: 'card', data: bt.getElement('card'), }); // Submit card token to our Next.js app's API // Example using Axios const { data } = await axios.post('/api/cards', { cardTokenId: token.id }); }; . What is Happening? . When a user submits their payment information, we will tokenize the underlying value of the CardElement. This will instruct Basis Theory Elements to submit this sensitive card data directly to Basis Theory’s Tokenize endpoint and return the resulting token identifiers to our front end, all without our application having accessed the sensitive card data directly. We are also creating a card Token Type. This is a PCI-compliant token type that will validate the card number using the LUHN algorithm and automatically expire the cvc property after one hour. The resulting token ID is safe to pass between your systems and store in plaintext within your preferred database. You can fully customize your card token, such as the alias, mask, and metadata by leveraging all of our token capabilities using Expressions. To not take on additional PCI scope, you cannot reveal more than the first six digits or last four digits of the card number via a combination of the alias and mask on your card token. ",
    "url": "https://developers.basistheory.com/blueprints/pci/#store-cards",
    "relUrl": "/blueprints/pci/#store-cards"
  },"64": {
    "doc": "PCI Blueprint",
    "title": "Process Cards",
    "content": "Now that we have our card token, we need to be able to send the cardholder data to a PCI-compliant payment service provider (PSP) such as Stripe or Braintree. In order to do this, we will send the data without touching the tokenized value. To accomplish this, we will use Basis Theory’s Proxy. Create a Private Application . First, you will need a Private Application using our PCI-compliant template Use PCI Tokens. This application will be used to securely send cardholder data via the Basis Theory Proxy to the PSP of your choice. Click here to create one. This will create a PCI-compliant application with the following Access Controls: . | Permissions: token:use | Containers: /pci/ | Transform: reveal | . Copy the API Key to be used in the next step. Send the Data to the Payment Service Provider . From our backend API, we will now be able to send the cardholder data associated with our token to a third-party PSP. Add the following code to your API, replacing PRIVATE_API_KEY with the API Key from the previous step:: . const { data } = await axios.post( 'https://api.basistheory.com/proxy', { card_number: `{{ ${cardTokenId} | json: '$.number' }}`, exp_month: `{{ ${cardTokenId} | json: '$.expiration_month' | to_number }}`, exp_year: `{{ ${cardTokenId} | json: '$.expiration_year' | to_number }}`, cvc: `{{ ${cardTokenId} | json: '$.cvc' }}` }, { headers: { 'BT-API-KEY': 'PRIVATE_API_KEY', 'BT-PROXY-URL': 'https://echo.basistheory.com/post', 'Content-Type': 'application/json' } }); . You should see a JSON response similar to: . { \"card_number\": \"4242424242424242\", \"exp_month\": 12, \"exp_year\": 2025, \"cvc\": \"123\" } . What is Happening? . A secure HTTPS request is made to Basis Theory’s Proxy endpoint. Basis Theory intercepts the request and detokenizes the Expressions in the request body. The detokenized request is then forwarded to the destination URL defined by the BT-PROXY-URL header passing request headers and query parameters along to the destination. This allows you to send the sensitive PCI cardholder data to any PCI-compliant third-party without touching the data and, therefore, keeping your systems out of PCI scope. You should ensure that any PCI cardholder data is only sent to PCI-certified third-parties. All PCI-certified services are required to maintain an up-to-date Attestation of Compliance (AOC) to accept and store cardholder information. More advanced Proxy scenarios can be configured via the Proxies endpoint, such as tokenizing inbound cardholder data before it touches your API or encrypting outbound API calls with an encryption key. ",
    "url": "https://developers.basistheory.com/blueprints/pci/#process-cards",
    "relUrl": "/blueprints/pci/#process-cards"
  },"65": {
    "doc": "PCI Blueprint",
    "title": "Conclusion",
    "content": "Following the PCI Blueprint enables you to remove 95% of the PCI compliance requirements by removing the need to touch the cardholder data when collecting, storing, and processing sensitive information. Have feedback or questions? Join us in our Slack community. ",
    "url": "https://developers.basistheory.com/blueprints/pci/#conclusion",
    "relUrl": "/blueprints/pci/#conclusion"
  },"66": {
    "doc": "Quickstart with cURL",
    "title": "Quickstart with cURL",
    "content": "In this tutorial, using cURL you will learn to use Basis Theory’s platform to secure a string of data and read the data back. Once you’ve completed this tutorial, you’ll have a foundational understanding of how to secure your data with Basis Theory allowing you to no longer worry about the underlying storage or encryption of the data. Looking for a Postman library? . If you are already familiar with Basis Theory and our platform in general, our guide on How to send Token data via HTTP or Collecting payments with Elements may be a better place to start. ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-curl/",
    "relUrl": "/getting-started/quickstart-with-curl/"
  },"67": {
    "doc": "Quickstart with cURL",
    "title": "Step 1: Ensure cURL is ready on your system",
    "content": "Unix/Linux/macOS: . Your system most likely has cURL already installed and you can check with the following command: . curl --help . Windows . There is a chance that if you have Windows 10 installed, you already have cURL. If the following command doesn’t work — here is help to get cURL installed. curl --help . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-curl/#step-1-ensure-curl-is-ready-on-your-system",
    "relUrl": "/getting-started/quickstart-with-curl/#step-1-ensure-curl-is-ready-on-your-system"
  },"68": {
    "doc": "Quickstart with cURL",
    "title": "Step 2: Create a new Application in your Basis Theory Account",
    "content": "If you don’t already have a Basis Theory account and your first Tenant, create one here. Within your Basis Theory account, create a new Application. To create a new Application, head to our portal here — this Application’s API Key will enable you to authenticate with the Basis Theory platform and create Tokens within your Tenant. 2.1 Select an Application Template . Select the Full Access Application Template, which will grant your Application access to create Tokens and read the plaintext Token values. 2.2 Enter an Application Name . This name allows you to identify this application in the future — for this tutorial enter “cURL Quickstart”. 2.3 Copy your API key . Keep this API key safe for later. We will use it in the next step to create your first Token. ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-curl/#step-2-create-a-new-application-in-your-basis-theory-account",
    "relUrl": "/getting-started/quickstart-with-curl/#step-2-create-a-new-application-in-your-basis-theory-account"
  },"69": {
    "doc": "Quickstart with cURL",
    "title": "Step 3: Create a Token to secure a string",
    "content": "Below we are making an HTTP POST to our Basis Theory Create a Token API, we will send a Token type of token (find out more about our Tokens here) with a string of “foo”. Update the BT-API-KEY header with the API Key you created in Step 2 and run the following command in your Terminal: . curl \"https://api.basistheory.com/tokens\" \\ -H \"BT-API-KEY: &lt;! ENTER YOUR API KEY HERE !&gt;\" \\ -H \"Content-Type: application/json\" \\ -X \"POST\" \\ -d '{ \"type\": \"token\", \"data\": \"foo\" }' . You will see a response similar to: . { \"id\": \"0a5767fd-e60a-4d73-bd6e-74b4f1e022df\", \"tenant_id\": \"71b86f56-e2e4-494c-b4f2-de8f38d1aee1\", \"type\": \"token\", \"containers\": [\"/general/high/\"], \"created_by\": \"69f12e84-4501-41e7-8f51-a74b307d7dc5\", \"created_at\": \"2022-01-22T15:13:14.3187199+00:00\" } . 🎉🎉🎉 You’ve created a token 🎉🎉🎉 . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-curl/#step-3-create-a-token-to-secure-a-string",
    "relUrl": "/getting-started/quickstart-with-curl/#step-3-create-a-token-to-secure-a-string"
  },"70": {
    "doc": "Quickstart with cURL",
    "title": "Step 4: Read back the raw value from Basis Theory",
    "content": "With our value safely stored in a Token, let’s read that value back to our system. To do this, we will make an HTTP GET request to the Basis Theory Get a Token API and print the response’s raw string value. You will need to replace &lt;! Token Id !&gt; with the id from the response in Step 3 and also replace &lt;! ENTER YOUR API KEY HERE !&gt; with your API Key from Step 2 — then run the following command in your Terminal: . curl \"https://api.basistheory.com/tokens/&lt;! Token Id !&gt;\" \\ -H \"BT-API-KEY: &lt;! ENTER YOUR API KEY HERE !&gt;\" . 🎉🎉🎉 You’ve successfully created a Token for your data and read it back! 🎉🎉🎉 . { \"id\": \"0a5767fd-e60a-4d73-bd6e-74b4f1e022df\", \"type\": \"token\", \"tenant_id\": \"71b86f56-e2e4-494c-b4f2-de8f38d1aee1\", \"data\": \"foo\", \"created_by\": \"69f12e84-4501-41e7-8f51-a74b307d7dc5\", \"created_at\": \"2022-01-22T15:13:14.3187199+00:00\", \"containers\": [\"/general/high/\"], } . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-curl/#step-4-read-back-the-raw-value-from-basis-theory",
    "relUrl": "/getting-started/quickstart-with-curl/#step-4-read-back-the-raw-value-from-basis-theory"
  },"71": {
    "doc": "Quickstart with cURL",
    "title": "What can I do next?",
    "content": "Now that you understand the basics, you are ready to learn more about how you can take advantage of your tokenized data with the capabilities of the Basis Theory platform. Check out the ability to use your Token data with HTTP request without the data ever touching your systems — or if you’re looking to secure Credit Card data, check out our guide on How To Charge a customer with Stripe while retaining access to the credit card number for future transactions. Was this useful, or looking for something different? Reach out to us on our Community. ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-curl/#what-can-i-do-next",
    "relUrl": "/getting-started/quickstart-with-curl/#what-can-i-do-next"
  },"72": {
    "doc": "Quickstart with .NET",
    "title": "Quickstart with .NET",
    "content": "In this tutorial, you will create a new .NET console application and use Basis Theory’s platform to secure a string of data and then read that data back out. Once you’ve completed this tutorial, you’ll have a foundational understanding of how to secure your data with Basis Theory allowing you to no longer worry about the underlying storage or encryption of the data. If you are already familiar with Basis Theory and our platform in general, our guide on How to send Token data via HTTP or Collecting payments with Elements may be a better place to start. If you’re looking for our a .NET library, you can find our nuget package here and or on our github repository. ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-dotnet/",
    "relUrl": "/getting-started/quickstart-with-dotnet/"
  },"73": {
    "doc": "Quickstart with .NET",
    "title": "Step 1: Get your .NET environment ready",
    "content": "Step 1.1: Ensure you have .NET installed . Completing this tutorial will require you to have the .NET 6.0 SDK or later installed on your local system. The latest .NET SDK can be downloaded here. Step 1.2: Create a .NET console application . To start, you will need a new .NET console application. Create a new console application in your IDE of choice named BasisTheoryQuickstart or use the following command to create the application: . mkdir BasisTheoryQuickstart cd BasisTheoryQuickstart dotnet new console . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-dotnet/#step-1-get-your-net-environment-ready",
    "relUrl": "/getting-started/quickstart-with-dotnet/#step-1-get-your-net-environment-ready"
  },"74": {
    "doc": "Quickstart with .NET",
    "title": "Step 2: Import needed dependencies",
    "content": "The simplest form of securing data with Basis Theory is through our API with a JSON body. In .NET, you can start with just an HttpClient, for this example we use the System.Net.Http and System.Text.Json assemblies to make an API call. At the top of your file, you’ll import the following dependencies: . using System.Net.Http.Json; using System.Text.Json; . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-dotnet/#step-2-import-needed-dependencies",
    "relUrl": "/getting-started/quickstart-with-dotnet/#step-2-import-needed-dependencies"
  },"75": {
    "doc": "Quickstart with .NET",
    "title": "Step 3: Create a new Application in your Basis Theory Account",
    "content": "If you don’t already have a Basis Theory account and your first Tenant, create one here. Within your Basis Theory account, create a new Application. To create a new Application, head to our portal here — this Application’s API Key will enable you to authenticate with the Basis Theory platform and create Tokens within your Tenant. 3.1 Select an Application Template . Select the Full Access Application Template, which will grant your Application access to create Tokens and read the plaintext Token values. 3.2 Enter an Application Name . This name allows you to identify this application in the future — for this tutorial enter “cURL Quickstart”. 3.3 Copy your API key . Keep this API key safe for later. We will use it in the next step to create your first Token. ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-dotnet/#step-3-create-a-new-application-in-your-basis-theory-account",
    "relUrl": "/getting-started/quickstart-with-dotnet/#step-3-create-a-new-application-in-your-basis-theory-account"
  },"76": {
    "doc": "Quickstart with .NET",
    "title": "Step 4: Create a Token to secure a string",
    "content": "To create a token, we need to send an HTTP POST request to the /tokens endpoint. In this guide, we will be using the token Token Type (you can read more about Tokens here). Update the BT-API-KEY header with the API Key you created in Step 3: . // Initialize the HttpClient using var httpClient = new HttpClient { BaseAddress = new Uri(\"https://api.basistheory.com\"), DefaultRequestHeaders = { { \"BT-API-KEY\", \"&lt;! ENTER YOUR API KEY HERE !&gt;\" } } }; // Initialize JSON Serializer options var jsonOptions = new JsonSerializerOptions { WriteIndented = true }; // Create a new Token var createResponse = await httpClient.PostAsJsonAsync(\"tokens\", new { type = \"token\", data = \"foo\" }); // Parse Token response into JSON object var token = await createResponse.Content.ReadFromJsonAsync&lt;JsonElement&gt;(); // Token response Console.WriteLine(\"Create a Token:\"); Console.WriteLine(JsonSerializer.Serialize(token, jsonOptions)); . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-dotnet/#step-4-create-a-token-to-secure-a-string",
    "relUrl": "/getting-started/quickstart-with-dotnet/#step-4-create-a-token-to-secure-a-string"
  },"77": {
    "doc": "Quickstart with .NET",
    "title": "Step 5: Run your application to create a new Token",
    "content": "To create a token, run the following command in the directory you created your console application: . dotnet run . You will see a response similar to: . &gt; Create a Token: { \"id\": \"0a5767fd-e60a-4d73-bd6e-74b4f1e022df\", \"tenant_id\": \"71b86f56-e2e4-494c-b4f2-de8f38d1aee1\", \"type\": \"token\", \"containers\": [\"/general/high/\"], \"created_by\": \"69f12e84-4501-41e7-8f51-a74b307d7dc5\", \"created_at\": \"2022-01-22T15:13:14.3187199+00:00\" } . 🎉🎉🎉 You’ve created a token 🎉🎉🎉 . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-dotnet/#step-5-run-your-application-to-create-a-new-token",
    "relUrl": "/getting-started/quickstart-with-dotnet/#step-5-run-your-application-to-create-a-new-token"
  },"78": {
    "doc": "Quickstart with .NET",
    "title": "Step 6: Read back the raw value from Basis Theory",
    "content": "With our value safely stored in a Token, let’s read that value back to our system. To do this, we will make an HTTP GET request to the Basis Theory Get a Token API endpoint and print the response’s raw string value. We are using the id property from the previous Token we created to inject the tokenId into the Get a token request. Update the BT-API-KEY header with the API Key you created in Step 3: . // Read the Token value back form Basis Theory and parse Token response into JSON object var tokenId = token.GetProperty(\"id\"); var getResponse = await httpClient.GetFromJsonAsync&lt;JsonElement&gt;($\"tokens/{tokenId}\"); // Display Token response Console.WriteLine(\"Read your Token:\"); Console.WriteLine(JsonSerializer.Serialize(getResponse, jsonOptions)); // Display raw secured value Console.WriteLine(\"Read your raw value from the Token:\"); Console.WriteLine(getResponse.GetProperty(\"data\")); . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-dotnet/#step-6-read-back-the-raw-value-from-basis-theory",
    "relUrl": "/getting-started/quickstart-with-dotnet/#step-6-read-back-the-raw-value-from-basis-theory"
  },"79": {
    "doc": "Quickstart with .NET",
    "title": "Step 7: Run the application",
    "content": "Test the entire tutorial out by running the application: . dotnet run . 🎉🎉🎉 You’ve successfully created a Token for your data and read it back 🎉🎉🎉 . &gt; Create a Token: { \"id\": \"0a5767fd-e60a-4d73-bd6e-74b4f1e022df\", \"tenant_id\": \"71b86f56-e2e4-494c-b4f2-de8f38d1aee1\", \"type\": \"token\", \"containers\": [\"/general/high/\"], \"created_by\": \"69f12e84-4501-41e7-8f51-a74b307d7dc5\", \"created_at\": \"2022-01-22T15:13:14.3187199+00:00\" } Read your Token: { \"id\": \"0a5767fd-e60a-4d73-bd6e-74b4f1e022df\", \"type\": \"token\", \"tenant_id\": \"71b86f56-e2e4-494c-b4f2-de8f38d1aee1\", \"data\": \"foo\", \"created_by\": \"69f12e84-4501-41e7-8f51-a74b307d7dc5\", \"created_at\": \"2022-01-22T15:13:14.3187199+00:00\", \"containers\": [\"/general/high/\"], } Read your raw value from the Token: foo . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-dotnet/#step-7-run-the-application",
    "relUrl": "/getting-started/quickstart-with-dotnet/#step-7-run-the-application"
  },"80": {
    "doc": "Quickstart with .NET",
    "title": "Put it all together",
    "content": "This completes the basic ability to secure data with Tokens and retrieve the raw data back from Basis Theory when you need to use the data in your systems. This flow allows you to secure your data at rest, removes the liability of having the data stored in your databases, and frees you from having to worry about complex encryption logic. using System.Net.Http.Json; using System.Text.Json; // Initialize the HttpClient using var httpClient = new HttpClient { BaseAddress = new Uri(\"https://api.basistheory.com\"), DefaultRequestHeaders = { { \"BT-API-KEY\", \"&lt;! ENTER YOUR API KEY HERE !&gt;\" } } }; // Initialize JSON Serializer options var jsonOptions = new JsonSerializerOptions { WriteIndented = true }; // Create a new Token var createResponse = await httpClient.PostAsJsonAsync(\"tokens\", new { type = \"token\", data = \"foo\" }); // Parse Token response into JSON object var token = await createResponse.Content.ReadFromJsonAsync&lt;JsonElement&gt;(); // Token response Console.WriteLine(\"Create a Token:\"); Console.WriteLine(JsonSerializer.Serialize(token, jsonOptions)); // Read the Token value back form Basis Theory and parse Token response into JSON object var tokenId = token.GetProperty(\"id\"); var getResponse = await httpClient.GetFromJsonAsync&lt;JsonElement&gt;($\"tokens/{tokenId}\"); // Display Token response Console.WriteLine(\"Read your Token:\"); Console.WriteLine(JsonSerializer.Serialize(getResponse, jsonOptions)); // Display raw secured value Console.WriteLine(\"Read your raw value from the Token:\"); Console.WriteLine(getResponse.GetProperty(\"data\")); . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-dotnet/#put-it-all-together",
    "relUrl": "/getting-started/quickstart-with-dotnet/#put-it-all-together"
  },"81": {
    "doc": "Quickstart with .NET",
    "title": "What can I do next?",
    "content": "Now that you understand the basics, you are ready to learn more about how you can better secure sensitive data without sacrificing data usability using the Basis Theory platform. Check out the ability to use your Token data with HTTP request without the data ever touching your systems — or if you’re looking to secure Credit Card data, check out our guide on How To Charge a customer with Stripe while retaining access to the credit card number for future transactions. Was this useful, or looking for something different? Reach out to us on our Community. ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-dotnet/#what-can-i-do-next",
    "relUrl": "/getting-started/quickstart-with-dotnet/#what-can-i-do-next"
  },"82": {
    "doc": "Quickstart with Go",
    "title": "Quickstart with Go",
    "content": "In this tutorial, you will create a new Go application and use Basis Theory’s platform to secure a string of data and then read that data back out. Once you’ve completed this tutorial, you’ll have a foundational understanding of how to secure your data with Basis Theory allowing you to no longer worry about the underlying storage or encryption of the data. If you are already familiar with Basis Theory and our platform in general, our guide on How to send Token data via HTTP or Collecting payments with Elements may be a better place to start. ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-go/",
    "relUrl": "/getting-started/quickstart-with-go/"
  },"83": {
    "doc": "Quickstart with Go",
    "title": "Step 1: Get your Go environment ready",
    "content": "Step 1.1: Ensure you have Go installed . Completing this tutorial will require you to have Go installed on your local system. The latest version of Go can be downloaded here. Step 1.2: Create a simple Go module . To start, you will need a new Go module. First, create a new directory to store the quickstart example: . mkdir BasisTheoryQuickstart cd BasisTheoryQuickstart . Next, initialize a new Go module: . go mod init BasisTheoryQuickstart . Create a new file named BasisTheoryQuickstart.go or use the following command to create the file: . // Mac or Linux touch BasisTheoryQuickstart.go // Windows type nul &gt; BasisTheoryQuickstart.go . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-go/#step-1-get-your-go-environment-ready",
    "relUrl": "/getting-started/quickstart-with-go/#step-1-get-your-go-environment-ready"
  },"84": {
    "doc": "Quickstart with Go",
    "title": "Step 2: Import needed dependencies",
    "content": "The simplest form of securing data with Basis Theory is through our API with a JSON body. Basis Theory maintains a Go SDK to make integrating with the platform that much easier. To install the Basis Theory Go SDK and its dependencies, run the following commands: . go get github.com/Basis-Theory/basistheory-go/v3 . Alternatively, you can import the package directly at the top of your new BasisTheoryQuickstart.go module: . import basistheory \"github.com/Basis-Theory/basistheory-go/v3\" . Then run: . go mod tidy . ‍ Note: at the time of writing, the latest version was v3. You can find the latest version in our documentation. ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-go/#step-2-import-needed-dependencies",
    "relUrl": "/getting-started/quickstart-with-go/#step-2-import-needed-dependencies"
  },"85": {
    "doc": "Quickstart with Go",
    "title": "Step 3: Create a new Application in your Basis Theory Account",
    "content": "If you don’t already have a Basis Theory account and your first Tenant, create one here. Within your Basis Theory account, create a new Application. To create a new Application, head to our portal here — this Application’s API Key will enable you to authenticate with the Basis Theory platform and create Tokens within your Tenant. 3.1 Select an Application Template . Select the Full Access Application Template, which will grant your Application access to create Tokens and read the plaintext Token values. 3.2 Enter an Application Name . This name allows you to identify this application in the future — for this tutorial enter “cURL Quickstart”. 3.3 Copy your API key . Keep this API key safe for later. We will use it in the next step to create your first Token. ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-go/#step-3-create-a-new-application-in-your-basis-theory-account",
    "relUrl": "/getting-started/quickstart-with-go/#step-3-create-a-new-application-in-your-basis-theory-account"
  },"86": {
    "doc": "Quickstart with Go",
    "title": "Step 4: Create a Token to secure a string",
    "content": "To create a token, we need to send an HTTP POST request to the /tokens endpoint. In this guide, we will be using the generic token Token Type (you can read more about Tokens here). Update the BT-API-KEY header with the API Key you created in Step 3! . (Note: some boilerplate code is missing in this snippet. The complete class is at the bottom of this guide!) . func main() { // Initialize new API Client configuration := basistheory.NewConfiguration() apiClient := basistheory.NewAPIClient(configuration) contextWithAPIKey := context.WithValue(context.Background(), basistheory.ContextAPIKeys, map[string]basistheory.APIKey{ \"ApiKey\": {Key: \"BT-API-KEY\"}, }) // Initialize the CreateTokenRequest createTokenRequest := *basistheory.NewCreateTokenRequest(\"Sensitive Value\") createTokenRequest.SetMask(\"\") createTokenRequest.SetType(\"token\") createTokenRequest.SetMetadata(map[string]string{ \"myMetadata\": \"myMetadataValue\", }) createTokenRequest.SetSearchIndexes([]string{\"\", \"\"}) createTokenRequest.SetFingerprintExpression(\"\") createTokenRequest.SetDeduplicateToken(true) // Send the request createTokenResponse, _, _ := apiClient.TokensApi.Create(contextWithAPIKey).CreateTokenRequest(createTokenRequest).Execute() fmt.Println(\"Token created:\") fmt.Printf(\"%v\", createTokenResponse) } . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-go/#step-4-create-a-token-to-secure-a-string",
    "relUrl": "/getting-started/quickstart-with-go/#step-4-create-a-token-to-secure-a-string"
  },"87": {
    "doc": "Quickstart with Go",
    "title": "Step 5: Run your application to create a new Token",
    "content": "To create a token, run the following commands in the directory you initialized your new Go module: . go run . You will see a response similar to: . &gt; Token created: {\"id\":\"62a71684-f148-424c-88c6-bdb44031357a\",\"tenant_id\":\"570b53fb-1ecf-4aaf-9cb2-145e13b566a9\",\"type\":\"token\",\"containers\":[\"/general/high/\"],\"created_by\":\"7281f0ef-eafc-455c-bdae-ce6c99ff8268\",\"created_at\":\"2022-02-17T21:49:29.2596915+00:00\"} . 🎉🎉🎉 You’ve created a token 🎉🎉🎉 . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-go/#step-5-run-your-application-to-create-a-new-token",
    "relUrl": "/getting-started/quickstart-with-go/#step-5-run-your-application-to-create-a-new-token"
  },"88": {
    "doc": "Quickstart with Go",
    "title": "Step 6: Read back the raw value from Basis Theory",
    "content": "With our value safely stored in a Token, let’s read it back. To do this, we will make an HTTP GET request to the Basis Theory Get a Token API endpoint and print the response’s raw string value. We are using the id property from the previous Token we created to inject the tokenId into the Get a token by ID request. token, _, _ := apiClient.TokensApi.GetById(contextWithAPIKey, createTokenResponse.GetId()).Execute() fmt.Println(\"Read a token:\") fmt.Printf(\"%v\", token) . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-go/#step-6-read-back-the-raw-value-from-basis-theory",
    "relUrl": "/getting-started/quickstart-with-go/#step-6-read-back-the-raw-value-from-basis-theory"
  },"89": {
    "doc": "Quickstart with Go",
    "title": "Step 7: Run the application",
    "content": "Test the entire tutorial out by running the application: . go run . 🎉🎉🎉 You’ve successfully created a Token for your data and read it back 🎉🎉🎉 . &gt; Token created: {\"id\":\"62a71684-f148-424c-88c6-bdb44031357a\",\"tenant_id\":\"570b53fb-1ecf-4aaf-9cb2-145e13b566a9\",\"type\":\"token\",\"containers\":[\"/general/high/\"],\"created_by\":\"7281f0ef-eafc-455c-bdae-ce6c99ff8268\",\"created_at\":\"2022-02-17T21:49:29.2596915+00:00\"} Read a token: {\"id\":\"62a71684-f148-424c-88c6-bdb44031357a\",\"type\":\"token\",\"tenant_id\":\"570b53fb-1ecf-4aaf-9cb2-145e13b566a9\",\"created_by\":\"7281f0ef-eafc-455c-bdae-ce6c99ff8268\",\"created_at\":\"2022-02-17T21:49:29.2596915+00:00\",\"containers\":[\"/general/high/\"]} . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-go/#step-7-run-the-application",
    "relUrl": "/getting-started/quickstart-with-go/#step-7-run-the-application"
  },"90": {
    "doc": "Quickstart with Go",
    "title": "Putting it all together",
    "content": "This completes the basic ability to secure data with Tokens and retrieve the raw data back from Basis Theory when you need to use the data in your systems. This flow allows you to secure your data at rest, removes the liability of having the data stored in your databases, and frees you from having to worry about complex encryption logic. package main import ( \"context\" \"fmt\" \"github.com/Basis-Theory/basistheory-go/v3\" ) func main() { // Initialize new API Client configuration := basistheory.NewConfiguration() apiClient := basistheory.NewAPIClient(configuration) contextWithAPIKey := context.WithValue(context.Background(), basistheory.ContextAPIKeys, map[string]basistheory.APIKey{ \"ApiKey\": {Key: \"BT-API-KEY\"}, }) // Initialize the CreateTokenRequest createTokenRequest := *basistheory.NewCreateTokenRequest(\"Sensitive Value\") createTokenRequest.SetMask(\"\") createTokenRequest.SetType(\"token\") createTokenRequest.SetMetadata(map[string]string{ \"myMetadata\": \"myMetadataValue\", }) createTokenRequest.SetSearchIndexes([]string{\"\", \"\"}) createTokenRequest.SetFingerprintExpression(\"\") createTokenRequest.SetDeduplicateToken(true) // Send the request createTokenResponse, _, _ := apiClient.TokensApi.Create(contextWithAPIKey).CreateTokenRequest(createTokenRequest).Execute() fmt.Println(\"Token created:\") fmt.Printf(\"%v\", createTokenResponse) // Read the token token, _, _ := apiClient.TokensApi.GetById(contextWithAPIKey, createTokenResponse.GetId()).Execute() fmt.Println(\"Read a token:\") fmt.Printf(\"%v\", token) } . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-go/#putting-it-all-together",
    "relUrl": "/getting-started/quickstart-with-go/#putting-it-all-together"
  },"91": {
    "doc": "Quickstart with Go",
    "title": "What can I do next?",
    "content": "Now that you understand the basics, you are ready to learn more about how you can better secure sensitive data without sacrificing data usability using the Basis Theory platform. Check out the ability to use your Token data with HTTP request without the data ever touching your systems — or if you’re looking to secure Credit Card data, check out our guide on How To Charge a customer with Stripe while retaining access to the credit card number for future transactions. Was this useful, or looking for something different? Reach out to us on our Community. ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-go/#what-can-i-do-next",
    "relUrl": "/getting-started/quickstart-with-go/#what-can-i-do-next"
  },"92": {
    "doc": "Quickstart with Java",
    "title": "Quickstart with Java",
    "content": "In this tutorial, you will create a new Java application and use Basis Theory’s platform to secure a string of data and then read that data back out. Once you’ve completed this tutorial, you’ll have a foundational understanding of how to secure your data with Basis Theory allowing you to no longer worry about the underlying storage or encryption of the data. If you are already familiar with Basis Theory and our platform in general, our guide on How to send Token data via HTTP or Collecting payments with Elements may be a better place to start. ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-java/",
    "relUrl": "/getting-started/quickstart-with-java/"
  },"93": {
    "doc": "Quickstart with Java",
    "title": "Step 1: Get your Java environment ready",
    "content": "Step 1.1: Ensure you have Java installed . We will use vanilla Java, without external dependencies. Completing this tutorial will require you to have the Java SE 17 or later installed on your local system. The latest version of Java can be downloaded here; OpenJDK can be downloaded here. Step 1.2: Create a simple Java class file . To start, you will need a new Java class file. Create a new file named BasisTheoryQuickstart.java or use the following command to create the application: . // Mac or Linux touch BasisTheoryQuickstart.java // Windows type nul &gt; BasisTheoryQuickstart.java . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-java/#step-1-get-your-java-environment-ready",
    "relUrl": "/getting-started/quickstart-with-java/#step-1-get-your-java-environment-ready"
  },"94": {
    "doc": "Quickstart with Java",
    "title": "Step 2: Import needed dependencies",
    "content": "The simplest form of securing data with Basis Theory is through our API with a JSON body. In Java 11 or later, you can start with just an HttpClient. For this example we use the java.net.http.HttpClient and related packages to make an API call. At the top of your file, you’ll import the following dependencies: . import java.net.URI; import java.net.http.HttpClient; import java.net.http.HttpRequest; import java.net.http.HttpRequest.BodyPublishers; import java.net.http.HttpResponse.BodyHandlers; . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-java/#step-2-import-needed-dependencies",
    "relUrl": "/getting-started/quickstart-with-java/#step-2-import-needed-dependencies"
  },"95": {
    "doc": "Quickstart with Java",
    "title": "Step 3: Create a new Application in your Basis Theory Account",
    "content": "If you don’t already have a Basis Theory account and your first Tenant, create one here. Within your Basis Theory account, create a new Application. To create a new Application, head to our portal here — this Application’s API Key will enable you to authenticate with the Basis Theory platform and create Tokens within your Tenant. 3.1 Select an Application Template . Select the Full Access Application Template, which will grant your Application access to create Tokens and read the plaintext Token values. 3.2 Enter an Application Name . This name allows you to identify this application in the future — for this tutorial enter “cURL Quickstart”. 3.3 Copy your API key . Keep this API key safe for later. We will use it in the next step to create your first Token. ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-java/#step-3-create-a-new-application-in-your-basis-theory-account",
    "relUrl": "/getting-started/quickstart-with-java/#step-3-create-a-new-application-in-your-basis-theory-account"
  },"96": {
    "doc": "Quickstart with Java",
    "title": "Step 4: Create a Token to secure a string",
    "content": "To create a token, we need to send an HTTP POST request to the /tokens endpoint. In this guide, we will be using the generic token Token Type (you can read more about Tokens here). Update the BT-API-KEY header with the API Key you created in Step 3! . (Note: some boilerplate code is missing in this snippet. The complete class is at the bottom of this guide!) . // Initialize the HttpClient var client = HttpClient.newHttpClient(); // JSON message formatted as a string var message = \"{\\\"type\\\": \\\"token\\\", \\\"data\\\": \\\"foo\\\"}\"; var createRequest = HttpRequest.newBuilder() .uri(URI.create(\"https://api.basistheory.com/tokens\")) .POST(BodyPublishers.ofString(message)) .header(\"Content-type\", \"application/json\") .header(\"Accept\", \"application/json\") // Enter your API key here! .header(\"BT-API-KEY\", \"&lt;! ENTER YOUR API KEY HERE !&gt;\") .build(); // Create a new token var createResponse = client.send(createRequest, BodyHandlers.ofString()); var token = createResponse.body(); // Token response System.out.println(\"Token created:\"); System.out.println(token); . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-java/#step-4-create-a-token-to-secure-a-string",
    "relUrl": "/getting-started/quickstart-with-java/#step-4-create-a-token-to-secure-a-string"
  },"97": {
    "doc": "Quickstart with Java",
    "title": "Step 5: Run your application to create a new Token",
    "content": "To create a token, run the following commands in the directory you created your BasisTheoryQuickstart.java file: . javac BasisTheoryQuickstart.java java BasisTheoryQuickstart . You will see a response similar to: . &gt; Token created: {\"id\":\"62a71684-f148-424c-88c6-bdb44031357a\",\"tenant_id\":\"570b53fb-1ecf-4aaf-9cb2-145e13b566a9\",\"type\":\"token\",\"containers\":[\"/general/high/\"],\"created_by\":\"7281f0ef-eafc-455c-bdae-ce6c99ff8268\",\"created_at\":\"2022-02-17T21:49:29.2596915+00:00\"} . 🎉🎉🎉 You’ve created a token 🎉🎉🎉 . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-java/#step-5-run-your-application-to-create-a-new-token",
    "relUrl": "/getting-started/quickstart-with-java/#step-5-run-your-application-to-create-a-new-token"
  },"98": {
    "doc": "Quickstart with Java",
    "title": "Step 6: Read back the raw value from Basis Theory",
    "content": "With our value safely stored in a Token, let’s read it back. To do this, we will make an HTTP GET request to the Basis Theory Get a Token API endpoint and print the response’s raw string value. We are using the id property from the previous Token we created to inject the tokenId into the Get a token by ID request. Because we are using vanilla Java, we will simply split the response and grab the id from the resulting array. // Parse token id from response var tokenArray = token.split(\"\\\"\"); var tokenId = tokenArray[3]; // Get token var getRequest = HttpRequest.newBuilder() .uri(URI.create(String.format(\"https://api.basistheory.com/tokens/%s\", tokenId))) .GET() .header(\"Content-type\", \"application/json\") .header(\"Accept\", \"application/json\") .header(\"BT-API-KEY\", \"key_E6gVJEn1DRT5m6YHs55Dsa\") .build(); var getResponse = client.send(getRequest, BodyHandlers.ofString()); System.out.println(\"Read a token:\"); System.out.println(getResponse.body()); . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-java/#step-6-read-back-the-raw-value-from-basis-theory",
    "relUrl": "/getting-started/quickstart-with-java/#step-6-read-back-the-raw-value-from-basis-theory"
  },"99": {
    "doc": "Quickstart with Java",
    "title": "Step 7: Run the application",
    "content": "Test the entire tutorial out by running the application: . javac BasisTheoryQuickstart.java java BasisTheoryQuickstart . 🎉🎉🎉 You’ve successfully created a Token for your data and read it back 🎉🎉🎉 . &gt; Create a token: {\"id\":\"62a71684-f148-424c-88c6-bdb44031357a\",\"tenant_id\":\"570b53fb-1ecf-4aaf-9cb2-145e13b566a9\",\"type\":\"token\",\"containers\":[\"/general/high/\"],\"created_by\":\"7281f0ef-eafc-455c-bdae-ce6c99ff8268\",\"created_at\":\"2022-02-17T21:49:29.2596915+00:00\"} Read a token: {\"id\":\"62a71684-f148-424c-88c6-bdb44031357a\",\"type\":\"token\",\"tenant_id\":\"570b53fb-1ecf-4aaf-9cb2-145e13b566a9\",\"created_by\":\"7281f0ef-eafc-455c-bdae-ce6c99ff8268\",\"created_at\":\"2022-02-17T21:49:29.2596915+00:00\",\"containers\":[\"/general/high/\"]} . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-java/#step-7-run-the-application",
    "relUrl": "/getting-started/quickstart-with-java/#step-7-run-the-application"
  },"100": {
    "doc": "Quickstart with Java",
    "title": "Putting it all together",
    "content": "This completes the basic ability to secure data with Tokens and retrieve the raw data back from Basis Theory when you need to use the data in your systems. This flow allows you to secure your data at rest, removes the liability of having the data stored in your databases, and frees you from having to worry about complex encryption logic. import java.net.URI; import java.net.http.HttpClient; import java.net.http.HttpRequest; import java.net.http.HttpRequest.BodyPublishers; import java.net.http.HttpResponse.BodyHandlers; public class BTQuickstart { public static void main(String[] args) { try { // Initialize the HttpClient var client = HttpClient.newHttpClient(); // JSON message formatted as a string var message = \"{\\\"type\\\": \\\"token\\\", \\\"data\\\": \\\"foo\\\"}\"; var createRequest = HttpRequest.newBuilder() .uri(URI.create(\"https://api.basistheory.com/tokens\")) .POST(BodyPublishers.ofString(message)) .header(\"Content-type\", \"application/json\") .header(\"Accept\", \"application/json\") // Enter your API key here! .header(\"BT-API-KEY\", \"key_E6gVJEn1DRT5m6YHs55Dsa\") .build(); // Create a new token var createResponse = client.send(createRequest, BodyHandlers.ofString()); var token = createResponse.body(); // Token response System.out.println(\"Create a token:\"); System.out.println(token); // Parse token id from response var tokenArray = token.split(\"\\\"\"); var tokenId = tokenArray[3]; // Get token var getRequest = HttpRequest.newBuilder() .uri(URI.create(String.format(\"https://api.basistheory.com/tokens/%s\", tokenId))) .GET() .header(\"Content-type\", \"application/json\") .header(\"Accept\", \"application/json\") .header(\"BT-API-KEY\", \"key_E6gVJEn1DRT5m6YHs55Dsa\") .build(); var getResponse = client.send(getRequest, BodyHandlers.ofString()); System.out.println(\"Read a token:\"); System.out.println(getResponse.body()); } catch (Exception e) { e.printStackTrace(); } } } . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-java/#putting-it-all-together",
    "relUrl": "/getting-started/quickstart-with-java/#putting-it-all-together"
  },"101": {
    "doc": "Quickstart with Java",
    "title": "What can I do next?",
    "content": "Now that you understand the basics, you are ready to learn more about how you can better secure sensitive data without sacrificing data usability using the Basis Theory platform. Check out the ability to use your Token data with HTTP request without the data ever touching your systems — or if you’re looking to secure Credit Card data, check out our guide on How To Charge a customer with Stripe while retaining access to the credit card number for future transactions. Was this useful, or looking for something different? Reach out to us on our Community. ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-java/#what-can-i-do-next",
    "relUrl": "/getting-started/quickstart-with-java/#what-can-i-do-next"
  },"102": {
    "doc": "Quickstart with Node.js",
    "title": "Quickstart with Node.js",
    "content": "In this tutorial, you will create a new Node.js script and use Basis Theory’s platform to secure a string of data and then read that data back out. Once you’ve completed this tutorial, you’ll have a foundational understanding of how to secure your data with Basis Theory allowing you to no longer worry about the underlying storage or encryption of the data. If you are already familiar with Basis Theory and our platform in general, our guide on How to send Token data via HTTP or Collecting payments with Elements may be a better place to start. If you’re looking for our NodeJS npm module, you can find our npm module here or on our github repository. ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-nodejs/",
    "relUrl": "/getting-started/quickstart-with-nodejs/"
  },"103": {
    "doc": "Quickstart with Node.js",
    "title": "Step 1: Get your Node.js environment ready",
    "content": "Step 1.1: Ensure you have Node.js installed . Completing this tutorial will require you to have Node.js installed on your local system or have an environment you can run your script in. If you’re looking for help getting Node.js installed for your system — check out their guide on installing. Step 1.2: Create a Node.js script . To start, you’ll need a new Node.js file. Use the following commands (or however you create files) to create a file called basistheory.js: . //Mac or Linux touch basistheory.js //Windows type nul &gt; basistheory.js . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-nodejs/#step-1-get-your-nodejs-environment-ready",
    "relUrl": "/getting-started/quickstart-with-nodejs/#step-1-get-your-nodejs-environment-ready"
  },"104": {
    "doc": "Quickstart with Node.js",
    "title": "Step 2: Import needed dependencies",
    "content": "Step 2.1: Install the axios npm package . To simplify our request to Basis Theory, we will install a helper package called axios. Axios is a promise-based HTTP client for Node.js. npm install axios . Step 2.2 Import the axios dependency in your script . The simplest form of securing data with Basis Theory is through our API with a JSON body. In Node.js, you can start with just an HTTP client libary, such as Axios. At the top of your file, add the following import statement(s): . const axios = require('axios'); . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-nodejs/#step-2-import-needed-dependencies",
    "relUrl": "/getting-started/quickstart-with-nodejs/#step-2-import-needed-dependencies"
  },"105": {
    "doc": "Quickstart with Node.js",
    "title": "Step 3: Create a new Application in your Basis Theory Account",
    "content": "If you don’t already have a Basis Theory account and your first Tenant, create one here. Within your Basis Theory account, create a new Application. To create a new Application, head to our portal here — this Application’s API Key will enable you to authenticate with the Basis Theory platform and create Tokens within your Tenant. 3.1 Select an Application Template . Select the Full Access Application Template, which will grant your Application access to create Tokens and read the plaintext Token values. 3.2 Enter an Application Name . This name allows you to identify this application in the future — for this tutorial enter “cURL Quickstart”. 3.3 Copy your API key . Keep this API key safe for later. We will use it in the next step to create your first Token. ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-nodejs/#step-3-create-a-new-application-in-your-basis-theory-account",
    "relUrl": "/getting-started/quickstart-with-nodejs/#step-3-create-a-new-application-in-your-basis-theory-account"
  },"106": {
    "doc": "Quickstart with Node.js",
    "title": "Step 4: Create a Token to secure a string",
    "content": "To create a token, we need to send an HTTP POST request to the /tokens endpoint. In this guide, we will be using the token Token Type (you can read more about Tokens here). We have wrapped our calls in a function called makeMyFirstToken to simplify axios promise response. Update the BT-API-KEY header with the API Key you created in Step 3: . const axios = require('axios'); async function makeMyFirstToken() { //Create first Token const token = await axios.post('https://api.basistheory.com/tokens', { type: 'token', data: 'foo', }, { headers: { 'Content-Type': 'application/json', 'BT-API-KEY': '&lt;! ENTER YOUR API KEY HERE !&gt;' } }) //Print Token response console.log(token.data) } // run quickstart code! makeMyFirstToken(); . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-nodejs/#step-4-create-a-token-to-secure-a-string",
    "relUrl": "/getting-started/quickstart-with-nodejs/#step-4-create-a-token-to-secure-a-string"
  },"107": {
    "doc": "Quickstart with Node.js",
    "title": "Step 5: Run your script to create a new Token",
    "content": "To create a token, run the following command in the directory you created your script: . node basistheory.js . You will see a response similar to: . { \"id\": \"0a5767fd-e60a-4d73-bd6e-74b4f1e022df\", \"tenant_id\": \"71b86f56-e2e4-494c-b4f2-de8f38d1aee1\", \"type\": \"token\", \"containers\": [\"/general/high/\"], \"created_by\": \"69f12e84-4501-41e7-8f51-a74b307d7dc5\", \"created_at\": \"2022-01-22T15:13:14.3187199+00:00\" } . 🎉🎉🎉 You’ve created a token 🎉🎉🎉 . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-nodejs/#step-5-run-your-script-to-create-a-new-token",
    "relUrl": "/getting-started/quickstart-with-nodejs/#step-5-run-your-script-to-create-a-new-token"
  },"108": {
    "doc": "Quickstart with Node.js",
    "title": "Step 6: Read back the raw value from Basis Theory",
    "content": "With our value safely stored in a Token, let’s read that value back to our system. To do this, we will make an HTTP GET request to the /tokens/{id} endpoint and print the response’s raw string value. We are using the token.data.id from the previous Token we created to inject the id into the Get a token request. Update the BT-API-KEY header with the API Key you created in Step 3: . const readToken = await axios.get(`https://api.basistheory.com/tokens/${token.data.id}`, { headers: { 'Content-Type': 'application/json', 'BT-API-KEY': '&lt;! ENTER YOUR API KEY HERE !&gt;' } }); //Print token we read console.log(\"Read your Token:\", readToken.data); console.log(\"Read your raw value from the Token:\", readToken.data.data); . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-nodejs/#step-6-read-back-the-raw-value-from-basis-theory",
    "relUrl": "/getting-started/quickstart-with-nodejs/#step-6-read-back-the-raw-value-from-basis-theory"
  },"109": {
    "doc": "Quickstart with Node.js",
    "title": "Step 7: Run the script",
    "content": "Test the entire tutorial out by running the script: . node basistheory.js . 🎉🎉🎉 You’ve successfully created and secured your data and read it back 🎉🎉🎉 . &gt; Create a Token: { \"id\": \"0a5767fd-e60a-4d73-bd6e-74b4f1e022df\", \"tenant_id\": \"71b86f56-e2e4-494c-b4f2-de8f38d1aee1\", \"type\": \"token\", \"containers\": [\"/general/high/\"], \"created_by\": \"69f12e84-4501-41e7-8f51-a74b307d7dc5\", \"created_at\": \"2022-01-22T15:13:14.3187199+00:00\" } Read your Token: { \"id\": \"0a5767fd-e60a-4d73-bd6e-74b4f1e022df\", \"type\": \"token\", \"tenant_id\": \"71b86f56-e2e4-494c-b4f2-de8f38d1aee1\", \"data\": \"foo\", \"containers\": [\"/general/high/\"], \"created_by\": \"69f12e84-4501-41e7-8f51-a74b307d7dc5\", \"created_at\": \"2022-01-22T15:13:14.3187199+00:00\" } Read your raw value from the Token: foo . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-nodejs/#step-7-run-the-script",
    "relUrl": "/getting-started/quickstart-with-nodejs/#step-7-run-the-script"
  },"110": {
    "doc": "Quickstart with Node.js",
    "title": "Put it all together",
    "content": "This completes the basic ability to secure data with Tokens and retrieve the raw data back from Basis Theory when you need to use the data in your systems. This flow allows you to secure your data at rest and removes the liability of having the data stored in your databases or having to worry about complex encryption logic. const axios = require('axios'); async function makeMyFirstToken() { //Create first Token const token = await axios.post('https://api.basistheory.com/tokens', { type: 'token', data: 'foo', }, { headers: { 'Content-Type': 'application/json', 'BT-API-KEY': '&lt;! ENTER YOUR API KEY HERE !&gt;' } }); //Print Token response console.log(\"Create a Token:\", token.data); const readToken = await axios.get(`https://api.basistheory.com/tokens/${token.data.id}`, { headers: { 'Content-Type': 'application/json', 'BT-API-KEY': '&lt;! ENTER YOUR API KEY HERE !&gt;' } }); //Print token we read console.log(\"Read your Token:\", readToken.data); console.log(\"Read your raw value from the Token:\", readToken.data.data); } // run quickstart code! makeMyFirstToken(); . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-nodejs/#put-it-all-together",
    "relUrl": "/getting-started/quickstart-with-nodejs/#put-it-all-together"
  },"111": {
    "doc": "Quickstart with Node.js",
    "title": "What can I do next?",
    "content": "Now that you understand the basics, you are ready to learn more about how you can better secure sensitive data without sacrificing data usability using the Basis Theory platform. Check out the ability to use your Token data with HTTP request without the data ever touching your systems — or if you’re looking to secure Credit Card data, check out our guide on How To Charge a customer with Stripe while retaining access to the credit card number for future transactions. Was this useful, or looking for something different? Reach out to us on our Community. ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-nodejs/#what-can-i-do-next",
    "relUrl": "/getting-started/quickstart-with-nodejs/#what-can-i-do-next"
  },"112": {
    "doc": "Quickstart with Python",
    "title": "Quickstart with Python",
    "content": "In this tutorial, you will create a new Python script and use Basis Theory’s platform to secure a string of data and then read that data back out. Once you’ve completed this tutorial, you’ll have a foundational understanding of how to secure your data with Basis Theory, allowing you to no longer worry about the underlying storage or encryption of the data. If you are already familiar with Basis Theory and our platform in general, our guide on “How to send Token data via HTTP” or “Collecting payments with Elements” may be better places to start. If you’re looking for our Python SDK, you can find it here or on our github repository. ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-python/",
    "relUrl": "/getting-started/quickstart-with-python/"
  },"113": {
    "doc": "Quickstart with Python",
    "title": "Step 1: Get your Python environment ready",
    "content": "Step 1.1: Ensure you have Python installed . Completing this tutorial will require you to have Python installed on your local system or have an environment you can run your script in. If you’re looking for help getting Python installed for your system — check out their guide on installing. Step 1.2: Ensure you have Pip installed . To check for pip try running the following command, if this command doesn’t work use the following guide to install it on your system. pip --help ##if the above doesn't work try pip3 --help . Step 1.3: Create a Python script . To start, you’ll need a new Python file. Use the following commands (or however you create files) to create a file called basistheory.py: . ##Mac or Linux touch basistheory.py ##Windows type nul &gt; basistheory.py . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-python/#step-1-get-your-python-environment-ready",
    "relUrl": "/getting-started/quickstart-with-python/#step-1-get-your-python-environment-ready"
  },"114": {
    "doc": "Quickstart with Python",
    "title": "Step 2: Import needed dependencies",
    "content": "Step 2.1: Install the requests pip package . To simplify our request to Basis Theory, we will install a helper package called requests. This package simplifies HTTP requests in Python. pip install requests ##If you used pip3 above: pip3 install requests . Step 2.2: Import the requests and json dependencies in your script . The simplest form of securing data with Basis Theory is through our API with a JSON body. In Python, this requires a few different libraries to make an API call. At the top of your file, you’ll import the following dependencies: . import requests import json . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-python/#step-2-import-needed-dependencies",
    "relUrl": "/getting-started/quickstart-with-python/#step-2-import-needed-dependencies"
  },"115": {
    "doc": "Quickstart with Python",
    "title": "Step 3: Create a new Application in your Basis Theory Account",
    "content": "If you don’t already have a Basis Theory account and your first Tenant, create one here. Within your Basis Theory account, create a new Application. To create a new Application, head to our portal here — this Application’s API Key will enable you to authenticate with the Basis Theory platform and create Tokens within your Tenant. 3.1 Select an Application Template . Select the Full Access Application Template, which will grant your Application access to create Tokens and read the plaintext Token values. 3.2 Enter an Application Name . This name allows you to identify this application in the future — for this tutorial enter “cURL Quickstart”. 3.3 Copy your API key . Keep this API key safe for later. We will use it in the next step to create your first Token. ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-python/#step-3-create-a-new-application-in-your-basis-theory-account",
    "relUrl": "/getting-started/quickstart-with-python/#step-3-create-a-new-application-in-your-basis-theory-account"
  },"116": {
    "doc": "Quickstart with Python",
    "title": "Step 4: Create a Token to secure a string",
    "content": "To create a token, we need to send an HTTP POST request to the /tokens endpoint. In this guide, we will be using the token Token Type (you can read more about Tokens here). Update the BT-API-KEY header with the API Key you created in Step 3: . import requests import json api_host = \"https://api.basistheory.com\" api_key = \"key_4qUtg83MpoVnDemfJwbzcN\" headers = { \"Content-Type\": \"application/json\", \"BT-API-KEY\": api_key } # Token object to create data = { \"type\": \"token\", \"data\": \"foo\" } # Create token and get response create_token_res = requests.post(f\"{api_host}/tokens\", json=data, headers=headers) token = create_token_res.json() print(\"Created Token:\") print(json.dumps(token, indent=2)) . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-python/#step-4-create-a-token-to-secure-a-string",
    "relUrl": "/getting-started/quickstart-with-python/#step-4-create-a-token-to-secure-a-string"
  },"117": {
    "doc": "Quickstart with Python",
    "title": "Step 5: Run your script to create a new Token",
    "content": "To create a token, run the following command in the directory you created your script: . python basistheory.py ##if the above doesn't work try python3 basistheory.py . You will see a response similar to: . Created Token: { \"id\": \"5646e5f5-0075-4932-b08b-77d4250eeea2\", \"tenant_id\": \"71b86f56-e2e4-494c-b4f2-de8f38d1aee1\", \"type\": \"token\", \"containers\": [\"/general/high/\"], \"created_by\": \"69f12e84-4501-41e7-8f51-a74b307d7dc5\", \"created_at\": \"2022-02-17T11:49:37.7616114+00:00\" } . 🎉🎉🎉 You’ve created a token 🎉🎉🎉 . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-python/#step-5-run-your-script-to-create-a-new-token",
    "relUrl": "/getting-started/quickstart-with-python/#step-5-run-your-script-to-create-a-new-token"
  },"118": {
    "doc": "Quickstart with Python",
    "title": "Step 6: Read back the raw value from Basis Theory",
    "content": "With our value safely stored in a Token, let’s read that value back to our system. To do this, we will make an HTTP GET request to the Basis Theory Get a Token API endpoint and print the response’s raw string value. We are using the token.id from the previous Token we created to inject the id into the Get a token request. You can use the same headers with the same BT-API-KEY that you used to create the Token: . get_token_res = requests.get(f\"{api_host}/tokens/{token['id']}\", headers=headers) fetched_token = get_token_res.json() print(\"\\nRead your Token:\") print(json.dumps(fetched_token, indent=2)) print(\"\\nRead raw Token data:\") print(fetched_token[\"data\"]) . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-python/#step-6-read-back-the-raw-value-from-basis-theory",
    "relUrl": "/getting-started/quickstart-with-python/#step-6-read-back-the-raw-value-from-basis-theory"
  },"119": {
    "doc": "Quickstart with Python",
    "title": "Step 7: Run the script",
    "content": "Test the entire tutorial out by running the script: . python basistheory.py ##if the above doesn't work try python3 basistheory.py . 🎉🎉🎉 You’ve successfully created secured your data and read it back: 🎉🎉🎉 . Created Token: { \"id\": \"5646e5f5-0075-4932-b08b-77d4250eeea2\", \"tenant_id\": \"71b86f56-e2e4-494c-b4f2-de8f38d1aee1\", \"type\": \"token\", \"containers\": [\"/general/high/\"], \"created_by\": \"69f12e84-4501-41e7-8f51-a74b307d7dc5\", \"created_at\": \"2022-02-17T11:49:37.7616114+00:00\" } Read your Token: { \"id\": \"5646e5f5-0075-4932-b08b-77d4250eeea2\", \"type\": \"token\", \"tenant_id\": \"71b86f56-e2e4-494c-b4f2-de8f38d1aee1\", \"data\": \"foo\", \"created_by\": \"69f12e84-4501-41e7-8f51-a74b307d7dc5\", \"created_at\": \"2022-02-17T11:49:37.7616114+00:00\", \"containers\": [\"/general/high/\"] } Read raw Token data: foo . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-python/#step-7-run-the-script",
    "relUrl": "/getting-started/quickstart-with-python/#step-7-run-the-script"
  },"120": {
    "doc": "Quickstart with Python",
    "title": "Put it all together",
    "content": "This completes the basic ability to secure data with Tokens and retrieve the raw data back from Basis Theory when you need to use the data in your systems. This flow allows you to secure your data at rest, removes the liability of having the data stored in your databases, and frees you from having to worry about complex encryption logic. import requests import json api_host = \"https://api.basistheory.com\" api_key = \"key_4qUtg83MpoVnDemfJwbzcN\" headers = { \"Content-Type\": \"application/json\", \"BT-API-KEY\": api_key } data = { 'type': 'token', 'data': 'foo' } create_token_res = requests.post(f\"{api_host}/tokens\", json=data, headers=headers) token = create_token_res.json() print(\"Created Token:\") print(json.dumps(token, indent=2)) get_token_res = requests.get(f\"{api_host}/tokens/{token['id']}\", headers=headers) fetched_token = get_token_res.json() print(\"\\nRead your Token:\") print(json.dumps(fetched_token, indent=2)) print(\"\\nRead raw Token data:\") print(fetched_token[\"data\"]) . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-python/#put-it-all-together",
    "relUrl": "/getting-started/quickstart-with-python/#put-it-all-together"
  },"121": {
    "doc": "Quickstart with Python",
    "title": "What can I do next?",
    "content": "Now that you understand the basics, you are ready to learn more about how you can better secure sensitive data without sacrificing data usability using the Basis Theory platform. Check out the ability to use your Token data with HTTP request without the data ever touching your systems — or if you’re looking to secure Credit Card data, check out our guide on How To Charge a customer with Stripe while retaining access to the credit card number for future transactions. Was this useful, or looking for something different? Reach out to us on our Community. ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-python/#what-can-i-do-next",
    "relUrl": "/getting-started/quickstart-with-python/#what-can-i-do-next"
  },"122": {
    "doc": "Quickstart with Ruby",
    "title": "Quickstart with Ruby",
    "content": "In this tutorial, you will create a new Ruby script and use Basis Theory’s platform to secure a string of data and then read that data back out. Once you’ve completed this tutorial, you’ll have a foundational understanding of how to secure your data with Basis Theory allowing you to no longer worry about the underlying storage or encryption of the data. If you are already familiar with Basis Theory and our platform in general, our guide on How to send Token data via HTTP or Collecting payments with Elements may be a better place to start. ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-ruby/",
    "relUrl": "/getting-started/quickstart-with-ruby/"
  },"123": {
    "doc": "Quickstart with Ruby",
    "title": "Step 1: Get your Ruby environment ready",
    "content": "Step 1.1: Ensure you have Ruby installed . Completing this tutorial will require you to have Ruby installed on your local system or have an environment you can run your script in. If you’re looking for help getting Ruby installed for your system — check out their guide on installing. Step 1.2: Create a Ruby script . To start, you’ll need a new Ruby file. Use the following commands (or however you create files) to create a file called basistheory.rb: . //Mac or Linux touch basistheory.rb //Windows type nul &gt; basistheory.rb . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-ruby/#step-1-get-your-ruby-environment-ready",
    "relUrl": "/getting-started/quickstart-with-ruby/#step-1-get-your-ruby-environment-ready"
  },"124": {
    "doc": "Quickstart with Ruby",
    "title": "Step 2: Import needed dependencies",
    "content": "The simplest form of securing data with Basis Theory is through our API with a JSON body. In Ruby, you can start with just an HTTP client library, for this example we use the uri, net/http, and json libraries to make an API call. At the top of your file, you’ll import the following dependencies: . require 'uri' require 'net/http' require 'json' . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-ruby/#step-2-import-needed-dependencies",
    "relUrl": "/getting-started/quickstart-with-ruby/#step-2-import-needed-dependencies"
  },"125": {
    "doc": "Quickstart with Ruby",
    "title": "Step 3: Create a new Application in your Basis Theory Account",
    "content": "If you don’t already have a Basis Theory account and your first Tenant, create one here. Within your Basis Theory account, create a new Application. To create a new Application, head to our portal here — this Application’s API Key will enable you to authenticate with the Basis Theory platform and create Tokens within your Tenant. 3.1 Select an Application Template . Select the Full Access Application Template, which will grant your Application access to create Tokens and read the plaintext Token values. 3.2 Enter an Application Name . This name allows you to identify this application in the future — for this tutorial enter “cURL Quickstart”. 3.3 Copy your API key . Keep this API key safe for later. We will use it in the next step to create your first Token. ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-ruby/#step-3-create-a-new-application-in-your-basis-theory-account",
    "relUrl": "/getting-started/quickstart-with-ruby/#step-3-create-a-new-application-in-your-basis-theory-account"
  },"126": {
    "doc": "Quickstart with Ruby",
    "title": "Step 4: Create a Token to secure a string",
    "content": "To create a token, we need to send an HTTP POST request to the /tokens endpoint. In this guide, we will be using the token Token Type (you can read more about Tokens here). Update the BT-API-KEY header with the API Key you created in Step 3: . #Create a new Token res = Net::HTTP.post URI('https://api.basistheory.com/tokens'), { \"type\" =&gt; \"token\", \"data\" =&gt; \"foo\" }.to_json, \"Content-Type\" =&gt; \"application/json\", \"BT-API-KEY\" =&gt; \"&lt;! ENTER YOUR API KEY HERE !&gt;\" #Parse Token response into Ruby object token = JSON.parse(res.body) #Token response puts JSON.pretty_generate(token) . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-ruby/#step-4-create-a-token-to-secure-a-string",
    "relUrl": "/getting-started/quickstart-with-ruby/#step-4-create-a-token-to-secure-a-string"
  },"127": {
    "doc": "Quickstart with Ruby",
    "title": "Step 5: Run your script to create a new Token",
    "content": "To create a token, run the following command in the directory you created your script: . ruby basistheory.rb . You will see a response similar to: . &gt; Create a Token: { \"id\": \"0a5767fd-e60a-4d73-bd6e-74b4f1e022df\", \"tenant_id\": \"71b86f56-e2e4-494c-b4f2-de8f38d1aee1\", \"type\": \"token\", \"containers\": [\"/general/high/\"], \"created_by\": \"69f12e84-4501-41e7-8f51-a74b307d7dc5\", \"created_at\": \"2022-01-22T15:13:14.3187199+00:00\" } . 🎉🎉🎉 You’ve created a token 🎉🎉🎉 . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-ruby/#step-5-run-your-script-to-create-a-new-token",
    "relUrl": "/getting-started/quickstart-with-ruby/#step-5-run-your-script-to-create-a-new-token"
  },"128": {
    "doc": "Quickstart with Ruby",
    "title": "Step 6: Read back the raw value from Basis Theory",
    "content": "With our value safely stored in a Token, let’s read that value back to our system. To do this, we will make an HTTP GET request to the Basis Theory Get a Token API endpoint and print the response’s raw string value. We are using the token[\"id\"] from the previous Token we created to inject the id into the Get a token request. Update the BT-API-KEY header with the API Key you created in Step 3: . #Read the Token value back form Basis Theory get_token_res = Net::HTTP.get URI(\"https://api.basistheory.com/tokens/#{token['id']}\"), \"Content-Type\" =&gt; \"application/json\", \"BT-API-KEY\" =&gt; \"&lt;! ENTER YOUR API KEY HERE !&gt;\" #Parse Token response into Ruby object raw_value = JSON.parse(get_token_res) #Display raw Token response puts JSON.pretty_generate(raw_value) #Display raw secured value puts raw_value[\"data\"] . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-ruby/#step-6-read-back-the-raw-value-from-basis-theory",
    "relUrl": "/getting-started/quickstart-with-ruby/#step-6-read-back-the-raw-value-from-basis-theory"
  },"129": {
    "doc": "Quickstart with Ruby",
    "title": "Step 7: Run the script",
    "content": "Test the entire tutorial out by running the script: . ruby basistheory.rb . 🎉🎉🎉 You’ve successfully created a Token for your data and read it back 🎉🎉🎉 . &gt; Create a Token: { \"id\": \"0a5767fd-e60a-4d73-bd6e-74b4f1e022df\", \"tenant_id\": \"71b86f56-e2e4-494c-b4f2-de8f38d1aee1\", \"type\": \"token\", \"containers\": [\"/general/high/\"], \"created_by\": \"69f12e84-4501-41e7-8f51-a74b307d7dc5\", \"created_at\": \"2022-01-22T15:13:14.3187199+00:00\" } Read your Token: { \"id\": \"0a5767fd-e60a-4d73-bd6e-74b4f1e022df\", \"type\": \"token\", \"tenant_id\": \"71b86f56-e2e4-494c-b4f2-de8f38d1aee1\", \"data\": \"foo\", \"created_by\": \"69f12e84-4501-41e7-8f51-a74b307d7dc5\", \"created_at\": \"2022-01-22T15:13:14.3187199+00:00\", \"containers\": [\"/general/high/\"] } Read your raw value from the Token: foo . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-ruby/#step-7-run-the-script",
    "relUrl": "/getting-started/quickstart-with-ruby/#step-7-run-the-script"
  },"130": {
    "doc": "Quickstart with Ruby",
    "title": "Put it all together",
    "content": "This completes the basic ability to secure data with Tokens and retrieve the raw data back from Basis Theory when you need to use the data in your systems. This flow allows you to secure your data at rest, removes the liability of having the data stored in your databases, and frees you from having to worry about complex encryption logic. require 'uri' require 'net/http' require 'json' #Create a new Token res = Net::HTTP.post URI('https://api.basistheory.com/tokens'), { \"type\" =&gt; \"token\", \"data\" =&gt; \"foo\" }.to_json, \"Content-Type\" =&gt; \"application/json\", \"BT-API-KEY\" =&gt; \"key_4qUtg83MpoVnDemfJwbzcN\" #Parse Token response into Ruby object token = JSON.parse(res.body) #Token response puts \"Create a Token:\", JSON.pretty_generate(token) #Read secured value back form Basis Theory get_token_res = Net::HTTP.get URI(\"https://api.basistheory.com/tokens/#{token['id']}\"), \"Content-Type\" =&gt; \"application/json\", \"BT-API-KEY\" =&gt; \"key_4qUtg83MpoVnDemfJwbzcN\" #Parse Token response into Ruby object raw_value = JSON.parse(get_token_res) #Display raw Token response puts \"Read your Token:\", JSON.pretty_generate(raw_value) #Display raw secured value puts \"Read your raw value from the Token:\", raw_value[\"data\"] . ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-ruby/#put-it-all-together",
    "relUrl": "/getting-started/quickstart-with-ruby/#put-it-all-together"
  },"131": {
    "doc": "Quickstart with Ruby",
    "title": "What can I do next?",
    "content": "Now that you understand the basics, you are ready to learn more about how you can better secure sensitive data without sacrificing data usability using the Basis Theory platform. Check out the ability to use your Token data with HTTP request without the data ever touching your systems — or if you’re looking to secure Credit Card data, check out our guide on How To Charge a customer with Stripe while retaining access to the credit card number for future transactions. Was this useful, or looking for something different? Reach out to us on our Community. ",
    "url": "https://developers.basistheory.com/getting-started/quickstart-with-ruby/#what-can-i-do-next",
    "relUrl": "/getting-started/quickstart-with-ruby/#what-can-i-do-next"
  },"132": {
    "doc": "Reveal Card Data with React",
    "title": "Reveal Card Data with React",
    "content": "This guide shows how you can safely reveal tokenized data to your users, without ever touching the detokenized data directly, keeping your systems out of compliance scope. It’s assumed on this guide that you are already familiar with the Basis Theory platform, but if that is not the case, please take a look at our getting started guides before going further. ",
    "url": "https://developers.basistheory.com/guides/reveal-cards-with-react/",
    "relUrl": "/guides/reveal-cards-with-react/"
  },"133": {
    "doc": "Reveal Card Data with React",
    "title": "Creating an Expiring Application",
    "content": "Basis Theory Elements can only retrieve token data by using an API key issued by an expiring application. This restriction is in place because the API key may be publicly exposed by the browser network calls when retrieving token data within a web application. An expiring application has an expiration date, meaning that after a specified amount of time (up to 1 day), the application’s API key expires and can no longer be used. This mitigates the risk of publicly exposing this API key. The following steps outline how to create an expiring application: . Enable “Create Expiring Application” on a Private Application . An expiring application can only be created by a private application, and not by a management application as is required for other application types. An expiring application can only be granted access to resources within the parent private application’s scope of access. In particular, this means that an expiring application cannot be granted access to tokens that are not accessible by the parent private application. In order for an expiring applications to be used to reveal token values, the issuing private application must either have the token:read permission or an access rule that grants the token:read permission to a subset of tokens. To enable a private application to create expiring applications, simply set the toggle in the Customer Portal, either during the private application creation or when updating an existing one: . Additionally, you can also enable this through our API or SDKs using the can_create_expiring_applications flag. Tokens of type card are automatically added to the /pci/high/ container. Your private application requires token:read access to the /pci/high/ container to continue with this tutorial. If you don’t have a private application yet that meets these criteria, you can click here to create one. Create The Expiring Application . Now that the private application has the ability to create expiring applications, you can use the private application API key to create expiring applications from your server-side code. The example below uses the Basis Theory JS SDK to accomplish this, but other SDKs are available to better fit your workflow. import { BasisTheory } from '@basis-theory/basis-theory-js'; const bt = await new BasisTheory().init('&lt;PRIVATE_APPLICATION_KEY&gt;'); const expiringApplication = await bt.applications.create({ type: 'expiring', expires_at: ttl(), rules: [ { description: 'Reveal Card', priority: 1, transform: 'reveal', // required for reveal conditions: [ { attribute: 'id', operator: 'equals', value: req.body.tokenId, // from the request made to the server-side code }, ], permissions: ['token:read'], // required for reveal }, ], }); . ",
    "url": "https://developers.basistheory.com/guides/reveal-cards-with-react/#creating-an-expiring-application",
    "relUrl": "/guides/reveal-cards-with-react/#creating-an-expiring-application"
  },"134": {
    "doc": "Reveal Card Data with React",
    "title": "Using Expiring Application Keys to Reveal Card with Elements React",
    "content": "Now that you are already creating expiring applications and fetching the keys with your client side code, those keys can be used to safely retrieve tokens and set their values onto Elements for users to see. Creating a CardElement with Basis Theory React . For this example, we are going to be using the Basis Theory React package to mount elements onto a React based frontend. The process of creating and mounting an Element is the same as usual. You still need a public application key for that. import { useRef } from 'react'; import { CardElement, useBasisTheory } from '@basis-theory/basis-theory-react'; import { CardElement as ICardElement } from '@basis-theory/basis-theory-js/types/elements'; export const DisplayCard = () =&gt; { const { bt } = useBasisTheory(); const cardRef = useRef&lt;ICardElement&gt;(null); return ( &lt;CardElement id=\"myCard\" ref={cardRef}/&gt; ); }; . Using the Expiring Application Key to Retrieve a Token with Elements . Assuming your client code is already fetching expiring application keys as per previous steps, these can then be used to retrieve a token value, granted that proper permissions are applied. Any attribute from the token like metadata can be directly accessible from the response, except for data, which represents just a reference to the actual data value that can be used with setValue in the next step. const cardToken = await bt.tokens.retrieve(tokenId, { apiKey: expiringKey }); . Revealing Token Data with Elements . As said previously, the retrieved token data value does not contain the actual data but just a reference to it. The actual data is safely stored in a Basis Theory iframe and can be set as the value for an Element input internally using the setValue method: . cardRef.current.setValue(cardToken.data) . Putting it All Together . See the complete code we created in this tutorial below. import { useRef } from 'react'; import { CardElement, useBasisTheory } from '@basis-theory/basis-theory-react'; import { CardElement as ICardElement } from '@basis-theory/basis-theory-js/types/elements'; export const DisplayCard = () =&gt; { const { bt } = useBasisTheory(); const cardRef = useRef&lt;ICardElement&gt;(null); const revealCard = async () =&gt; { // fetching the expiring application key from your server side code const { data: { expiringKey }, } = await axios.post('/api/authorize'); // using the expiring application key to retrieve the token const cardToken = await bt.tokens.retrieve(tokenId, { apiKey: expiringKey }); // setting the token data value into the CardElement cardRef.current.setValue(cardToken.data); } return ( &lt;&gt; &lt;CardElement id=\"myCard\" ref={cardRef}/&gt; &lt;button type=\"button\" onClick={revealCard}&gt;Reveal Card&lt;/button&gt; &lt;/&gt; ); }; . That’s it, now the token data can be displayed to the user 🎉, and since your client-side application does not have direct access to the actual data value, it falls out of compliance scope. ",
    "url": "https://developers.basistheory.com/guides/reveal-cards-with-react/#using-expiring-application-keys-to-reveal-card-with-elements-react",
    "relUrl": "/guides/reveal-cards-with-react/#using-expiring-application-keys-to-reveal-card-with-elements-react"
  },"135": {
    "doc": "Reveal Card Data with React",
    "title": "Demo Repository",
    "content": "To better demonstrate this feature, we made available a demo repository that you can clone and run on your local machine. This repository showcases some best practices and techniques for simplifying working with Elements, including: . | Shows how to build a CardElement for collecting cards that will be subsequently revealed. | Using the split CardNumberElement, CardExpirationDateElement and CardVerificationCodeElement to create a UI that resembles a credit card visually when revealing values. | Uses the NextJS server side API to fetch expiring application keys in real time. | . ",
    "url": "https://developers.basistheory.com/guides/reveal-cards-with-react/#demo-repository",
    "relUrl": "/guides/reveal-cards-with-react/#demo-repository"
  },"136": {
    "doc": "Run Your Own Code in a Reactor",
    "title": "Run Your Own Code in a Reactor",
    "content": "Basis Theory offers several pre-built Official Reactor Formulas that support standard integrations with popular Third Party systems. While these Official formulas are helpful to quickly get up and running for common use cases, we understand that every business has unique needs and challenges around how they use their data, and oftentimes custom code is required to achieve these goals. In this guide, we will walk through how to create a Private Reactor Formula to run your own custom code. If you are completely new to Reactors and would like to first learn the basics, check out our Reactors concept page. If you’d rather learn about how to use one of our Official Reactor Formulas, check out our guide on how to Use Token Data in Reactors. | How to Configure a Reactor Formula | How to Write Code for a Reactor Formula . | Importing Dependencies | Error Handling | . | Creating a Private Reactor Formula | Using Our Private Reactor Formula | Wrapping Up | . ",
    "url": "https://developers.basistheory.com/guides/run-your-own-code-in-a-reactor/",
    "relUrl": "/guides/run-your-own-code-in-a-reactor/"
  },"137": {
    "doc": "Run Your Own Code in a Reactor",
    "title": "How to Configure a Reactor Formula",
    "content": "When defining a Reactor Formula, you have a few options for providing input data to be used within your custom code. Configuration is used to declare parameters that will be defined once per Reactor and do not change between Reactor invocations. Declare a configuration property on a Reactor Formula for each property you wish to be statically defined, such as an API key for a third-party API, or an environment variable. Request Parameters are used to declare parameters that will be provided with every Reactor invocation and are expected to vary between requests. Declare a request parameter on a Reactor Formula for each property you wish to supply at runtime, such as a user’s card number or a transaction amount. The args provided with each request to invoke a Reactor are validated against the request parameter declarations on the Reactor Formula. To access sensitive data within a Reactor Formula, tokens may be provided within the args to satisfy the request parameter contract - requests to invoke a Reactor are first detokenized to replace any detokenization expressions within the args and the request provided to the Reactor Formula Code will contain your detokenized sensitive data. ",
    "url": "https://developers.basistheory.com/guides/run-your-own-code-in-a-reactor/#how-to-configure-a-reactor-formula",
    "relUrl": "/guides/run-your-own-code-in-a-reactor/#how-to-configure-a-reactor-formula"
  },"138": {
    "doc": "Run Your Own Code in a Reactor",
    "title": "How to Write Code for a Reactor Formula",
    "content": "Reactors provide an isolated serverless Node.js v14 runtime in which your custom code is securely executed. Reactor Formulas are written using (Node.js v14-compatible) Javascript and have the following general structure: . module.exports = async function (req) { const { my_arg } = req.args; // access any args provided with the request const { MY_CONFIG } = req.configuration; // access any static config defined on the Reactor // do anything here! return { raw: {}, // non-sensitive data that should be returned in plaintext tokenize: {} // sensitive data that should be tokenized }; }; . If you’re interested in writing custom Reactor Formulas using a language other than Javascript, please reach out and let us know! . The request object provided to a Reactor Formula contains the following properties: . | args: detokenized runtime arguments provided when invoking the Reactor . | body: when executing in the context of the proxy, this will contain the detokenized body of the request | headers: when executing in the context of the proxy, this will contain the headers of the request | . | configuration: static configuration defined with the Reactor | bt: a pre-configured Basis Theory JS instance for the application defined with the Reactor. This will be null if no application was defined | . The response returned from a Reactor Formula may contain the following properties: . | raw: non-sensitive data that will be returned in plaintext . | body: the body forwarded to the destination for the proxy request | headers: the headers to be forwarded to the destination for the proxy request | . | tokenize: sensitive data that will be tokenized before returning it in the response | . Exercise caution when returning plaintext data within the raw portion of the response - the systems that invoke your Reactor will receive this raw data in the HTTP response and returning sensitive data in plaintext could result in these systems being pulled into compliance scope. While you have the freedom to author your Reactor Formula in any way you wish, we recommend that you strive to keep all sensitive data isolated within Basis Theory’s secure and compliant infrastructure. We generally recommend that any potentially sensitive output be tokenized in order to shield your systems. Importing Dependencies . You are able to import dependencies within Reactor Formulas. For example, node-fetch can be imported into your code and used to make an HTTP request: . module.exports = async function (req) { const { card_number } = req.args; const { API_KEY } = req.configuration; const fetch = require('node-fetch'); const res = await fetch(`https://api.company.com/`, { headers: { 'X-API-KEY': API_KEY, 'Content-Type': 'application/json' }, method: 'POST', body: JSON.stringify({ cardNumber: card_number }) }); return { ... }; }; . In order to ensure the security and integrity of the Reactor execution environment, only approved NPM packages can be used within Reactor Formulas. If you are interested in using a specific NPM package within your custom code, please submit a request to have this package reviewed and whitelisted. Error Handling . Many third party APIs or SDKs return errors in unique ways, so Reactor Formulas are expected to catch and handle any errors that occur during execution. Any errors that occur during the execution of your Reactor Formula should be caught, translated into a standard Basis Theory Reactor error, and this standardized error rethrown from the formula. The standard Basis Theory Reactor errors are defined within the NPM package @basis-theory/basistheory-reactor-formulas-sdk-js, which is available to import from within your Reactor Formulas. These standard error types will be translated by the Reactor execution environment into HTTP errors returned from the Basis Theory API. Any other uncaught exceptions thrown from a Reactor Formula will be returned as a generic HTTP 500 error and the original error message will be lost. The Reactor Formula will be retried up to 3 times in the event of any transient errors (an HTTP status code &gt;=500 or 408 Request Timeout). As an example, if you are working with an API that returns errors indicated by HTTP response status codes, your formula can translate from these potentially vendor-specific status codes to a standard Basis Theory error as follows: . module.exports = async function (req) { const { AuthenticationError, BadRequestError, ReactorRuntimeError, } = require('@basis-theory/basis-theory-reactor-formulas-sdk-js'); const fetch = require('node-fetch'); const res = await fetch(...); const response = await res.json(); if (res.status !== 200) { switch (res.status) { case 401: throw new AuthenticationError(response); case 400: throw new BadRequestError(response); default: throw new ReactorRuntimeError(response); } } // ... }; . Any object or array passed into the constructor of a standard Basis Theory Reactor error will be returned in the errors property of the HTTP response when invoking the Reactor. Use caution when returning data through errors, as it will be returned in plaintext and not be tokenized or masked. ",
    "url": "https://developers.basistheory.com/guides/run-your-own-code-in-a-reactor/#how-to-write-code-for-a-reactor-formula",
    "relUrl": "/guides/run-your-own-code-in-a-reactor/#how-to-write-code-for-a-reactor-formula"
  },"139": {
    "doc": "Run Your Own Code in a Reactor",
    "title": "Creating a Private Reactor Formula",
    "content": "As an example, we will be creating a custom Reactor Formula that interacts with the Lithic API to issue a credit card from our hypothetical company’s corporate Lithic account. We will allow setting a single configuration parameter with this Reactor, the API key issued by Lithic for our account: . | Name | Type | Description | . | LITHIC_API_KEY | string | The api key issued by Lithic | . We will also allow requests to our Reactor to specify several parameters that we will forward to the Lithic API to control the name of our new card, the type of card to create, and the spend limit of the card: . | Name | Type | Description | . | memo | string | The name to identify the card | . | type | string | The type of card to issue (see Lithic docs) | . | spend_limit | number | The amount (in cents) to limit approved authorizations | . | spend_limit_duration | string | Duration for which spend limit applies (see Lithic docs | . We can then use these configuration and request parameters in our Reactor Formula code to make an API request to Lithic. We will also create a card token as output from this Reactor using the card details provided to us in the Lithic API response. module.exports = async function (req) { const { LITHIC_API_KEY } = req.configuration; const { memo, type, spend_limit, spend_limit_duration } = req.args; const fetch = require('node-fetch'); const body = { memo, type, spend_limit, spend_limit_duration, state: 'OPEN' }; const response = await fetch( `https://sandbox.lithic.com/v1/card`, { method: 'post', body: JSON.stringify(body), headers: { 'Authorization': `api-key ${LITHIC_API_KEY}`, 'Content-Type': 'application/json', } } ); // omitted for brevity: translate response status codes to Basis Theory Reactor errors const lithicCard = await response.json(); return { tokenize: { type: 'card', data: { number: lithicCard.pan, expiration_month: lithicCard.exp_month, expiration_year: lithicCard.exp_year, cvc: lithicCard.cvv }, metadata: { lithic_token_id: lithicCard.token } } }; } . Next, we need to create a Private Reactor Formula in Basis Theory containing this code, configuration, and request_parameters by calling the Create Reactor Formula API. Note that all newline characters must be escaped as \\n within the code property of the JSON request: . curl 'https://api.basistheory.com/reactor-formulas' \\ -X 'POST' \\ -H 'BT-API-KEY: key_PtkNaBwXe23rGt1eZenMMx' \\ -H 'Content-Type: application/json' \\ -d '{ \"name\": \"Lithic - Issue Card\", \"description\": \"Issues a new card using Lithic\", \"type\": \"private\", \"code\": \"module.exports = async function (req) {\\n const { LITHIC_API_KEY } = req.configuration;\\n const { memo, type, spend_limit, spend_limit_duration } = req.args;\\n \\n const fetch = require('node-fetch');\\n \\n const body = {\\n memo,\\n type,\\n spend_limit,\\n spend_limit_duration,\\n state: 'OPEN'\\n };\\n \\n const response = await fetch(\\n `https://sandbox.lithic.com/v1/card`,\\n {\\n method: 'post',\\n body: JSON.stringify(body),\\n headers: { \\n 'Authorization': `api-key ${LITHIC_API_KEY}`,\\n 'Content-Type': 'application/json',\\n }\\n }\\n );\\n const lithicCard = await response.json();\\n \\n return { \\n tokenize: {\\n type: 'card',\\n data: {\\n number: lithicCard.pan,\\n expiration_month: lithicCard.exp_month,\\n expiration_year: lithicCard.exp_year,\\n cvc: lithicCard.cvv\\n },\\n metadata: {\\n lithic_token_id: lithicCard.token\\n }\\n }\\n };\\n }\\n\", \"configuration\": [ { \"name\": \"LITHIC_API_KEY\", \"description\": \"The api key issued by Lithic\", \"type\": \"string\" } ], \"request_parameters\": [ { \"name\": \"memo\", \"description\": \"The name to identify the card\", \"type\": \"string\", \"optional\": false }, { \"name\": \"type\", \"description\": \"The type of card to issue\", \"type\": \"string\", \"optional\": false }, { \"name\": \"spend_limit\", \"description\": \"The amount (in cents) to limit approved authorizations\", \"type\": \"number\", \"optional\": true }, { \"name\": \"spend_limit_duration\", \"description\": \"Duration for which spend limit applies\", \"type\": \"string\", \"optional\": true } ] }' . The API will respond with the id of our new Private Reactor Formula: . { \"id\": \"886f14ab-9404-444e-ae44-848c87d1ff88\", \"type\": \"private\", \"status\": \"verified\", \"name\": \"Lithic - Issue Card\", \"description\": \"Issues a new card using Lithic\", ... } . ",
    "url": "https://developers.basistheory.com/guides/run-your-own-code-in-a-reactor/#creating-a-private-reactor-formula",
    "relUrl": "/guides/run-your-own-code-in-a-reactor/#creating-a-private-reactor-formula"
  },"140": {
    "doc": "Run Your Own Code in a Reactor",
    "title": "Using Our Private Reactor Formula",
    "content": "Next, we will use this Reactor Formula to create a Reactor that contains the LITHIC_API_KEY to interact on behalf of our company’s Lithic account: . curl 'https://api.basistheory.com/reactors' \\ -X 'POST' \\ -H 'BT-API-KEY: key_PtkNaBwXe23rGt1eZenMMx' \\ -H 'Content-Type: application/json' \\ -d '{ \"name\": \"Lithic - Issue Card from My Company\", \"configuration\": { \"LITHIC_API_KEY\": \"02f0a915-6226-4a8b-861e-58b08984106f\" }, \"formula\": { \"id\": \"886f14ab-9404-444e-ae44-848c87d1ff88\" } }' . The Basis Theory API will respond with the id of our new Reactor, which we will use later to invoke our Reactor: . { \"id\": \"ab8a1c9a-8666-449d-91c7-6c0d77bf7d02\", \"name\": \"Lithic - Issue Card from My Company\", \"configuration\": { \"LITHIC_API_KEY\": \"02f0a915-6226-4a8b-861e-58b08984106f\" }, \"formula\": {...}, ... } . Now that we have created a Reactor that uses our private formula, we can now make requests to it. We will use the Invoke a Reactor endpoint with args that instruct our Reactor to issue a card called John's Travel Card with a total spending limit of $500. curl 'https://api.basistheory.com/reactors/ab8a1c9a-8666-449d-91c7-6c0d77bf7d02/react' \\ -X 'POST' \\ -H 'BT-API-KEY: key_PtkNaBwXe23rGt1eZenMMx' \\ -H 'Content-Type: application/json' \\ -d '{ \"args\": { \"memo\": \"John'\\''s Travel Card\", \"type\": \"UNLOCKED\", \"spend_limit\": 50000, \"spend_limit_duration\": \"FOREVER\" } }' . The Basis Theory API will respond with a newly created card token that contains the card details issued by Lithic. { \"tokens\": { \"id\": \"27ca2332-826f-4064-935a-603bfc5d8fb0\", \"type\": \"card\", \"data\": { \"number\": \"XXXXXXXXXXXX8208\", \"expiration_month\": 4, \"expiration_year\": 2028 }, \"metadata\": { \"lithic_token_id\": \"de9fd4cf-fd5b-4ebc-8a25-3a564bc375c2\" }, ... } } . ",
    "url": "https://developers.basistheory.com/guides/run-your-own-code-in-a-reactor/#using-our-private-reactor-formula",
    "relUrl": "/guides/run-your-own-code-in-a-reactor/#using-our-private-reactor-formula"
  },"141": {
    "doc": "Run Your Own Code in a Reactor",
    "title": "Wrapping Up",
    "content": "We’ve seen how to create Private Reactor Formulas to run your own code within Basis Theory’s serverless Reactor infrastructure. By bringing your own code, you have the flexibility to use your token data however you need - the possibilities of what you can do with Reactors are virtually unlimited. ",
    "url": "https://developers.basistheory.com/guides/run-your-own-code-in-a-reactor/#wrapping-up",
    "relUrl": "/guides/run-your-own-code-in-a-reactor/#wrapping-up"
  },"142": {
    "doc": "Styling Elements",
    "title": "How to style Elements for my brand",
    "content": "Our Elements have been built to act as normal input fields within your own application. We’ve taken care in building out the supported styles and needs of our customers. In this guide, we will walk you through a few of the different styles you can adjust. Want to just jump into an example? Check it out here! . | Update the base variant of Elements | Update variant styles | . ",
    "url": "https://developers.basistheory.com/guides/style-elements-for-my-brand/#how-to-style-elements-for-my-brand",
    "relUrl": "/guides/style-elements-for-my-brand/#how-to-style-elements-for-my-brand"
  },"143": {
    "doc": "Styling Elements",
    "title": "Update the base variant of Elements",
    "content": "The base variant in our style object enables you to update the way the input fields look during most user interactions (invalid, typing, etc.). For security reasons, we only support fonts from Google’s list of supported fonts. If you’re looking to include an additional font that you can’t find, reach out and let us know in our Community. var cardElement = BasisTheory.createElement('card', { style: { fonts: [ \"https://fonts.googleapis.com/css2?family=Inter:ital,wght@0,200;0,300;0,400;0,600;0,700;0,900;1,200;1,300;1,400;1,600;1,700;1,900&amp;display=swap\" ], base: { color: \"#fff\", fontWeight: 500, fontFamily: \"'Inter'\", fontSize: \"16px\", fontSmooth: \"antialiased\", \"::placeholder\": { color: \"#6b7294\" } } } }); . ",
    "url": "https://developers.basistheory.com/guides/style-elements-for-my-brand/#update-the-base-variant-of-elements",
    "relUrl": "/guides/style-elements-for-my-brand/#update-the-base-variant-of-elements"
  },"144": {
    "doc": "Styling Elements",
    "title": "Update variant styles",
    "content": "These styling configurations allow you to easily update what happens when users engage with the input fields, no matter if that is when an invalid value is entered or when they simply hover over the fields. Ready to see all the options our variants provide? Checkout our Elements Style Documentation. var cardElement = BasisTheory.createElement('card', { style: { fonts: [ \"https://fonts.googleapis.com/css2?family=Inter:ital,wght@0,200;0,300;0,400;0,600;0,700;0,900;1,200;1,300;1,400;1,600;1,700;1,900&amp;display=swap\" ], invalid: { color: \"#ffc7ee\" }, complete: { color: \"#1ad1db\" } } }); . ",
    "url": "https://developers.basistheory.com/guides/style-elements-for-my-brand/#update-variant-styles",
    "relUrl": "/guides/style-elements-for-my-brand/#update-variant-styles"
  },"145": {
    "doc": "Styling Elements",
    "title": "See it in action",
    "content": "See a sample and the code that drives it below. Want to experience the sandbox yourself? Check it out here. ",
    "url": "https://developers.basistheory.com/guides/style-elements-for-my-brand/#see-it-in-action",
    "relUrl": "/guides/style-elements-for-my-brand/#see-it-in-action"
  },"146": {
    "doc": "Styling Elements",
    "title": "Styling Elements",
    "content": " ",
    "url": "https://developers.basistheory.com/guides/style-elements-for-my-brand/",
    "relUrl": "/guides/style-elements-for-my-brand/"
  },"147": {
    "doc": "Use Token Data in Reactors",
    "title": "Use Token Data in Reactors",
    "content": "In this guide, we will show you how to use the pre-built Parrot BIN service Reactor Formula to take your tokenized card data and capture new analytical insights. If you are completely new to Reactors and would like to learn more about what they are before trying them out, check out our Reactors concept page. | Create a Reactor | Use Your New Reactor . | Use a Card Number Token | Use a Card Token | Use a Card Token with a JSON Path Transformation | . | . ",
    "url": "https://developers.basistheory.com/guides/use-token-data-in-reactors/",
    "relUrl": "/guides/use-token-data-in-reactors/"
  },"148": {
    "doc": "Use Token Data in Reactors",
    "title": "Create a Reactor",
    "content": "Initially, we will show you how to create a Reactor from our portal, although you can also use the Basis Theory API to replicate these steps within your own CI pipelines or code base. Once you’re logged into the Basis Theory Portal, navigate to our Reactors page and click on “Create Reactor” on the top right to begin creating a new Reactor. On this page, you’ll see a listing of all available Reactor Formulas. Selecting a Reactor Formula will slide out a view to explain that formula’s requirements. The Configuration section allows you to configure API keys or environment variables that remain static across Reactor invocations, while the Request Parameters section will show you the arguments you must send to the /react endpoint each time it is invoked. Once you find the Reactor Formula you want to create, select “Use this formula” to start creating a Reactor. Next, you’ll be able to name and add any additional configuration to the Reactor. That’s it! Once you’ve saved your first Reactor, you can begin interacting with it via our API. As always, you can create the same results with the Basis Theory API to codify the creation of Reactors. ",
    "url": "https://developers.basistheory.com/guides/use-token-data-in-reactors/#create-a-reactor",
    "relUrl": "/guides/use-token-data-in-reactors/#create-a-reactor"
  },"149": {
    "doc": "Use Token Data in Reactors",
    "title": "Use Your New Reactor",
    "content": "With your Reactor created, it’s time to start using your tokens in it. Depending on which Reactor Formula you chose to create a Reactor from, you’ll need to pass in the corresponding request parameters it needs. The Parrot Reactor Formula requires only a single parameter: . | name | type | optional | . | card.number | string | false | . Request parameters are provided when invoking a Reactor via the args request property. In order to satisfy the request parameter contract defined on the Reactor Formula, you may supply any mixture of constant values and detokenization expressions within args. Next, we’ll walk through a couple ways in which you could invoke the Parrot reactor to provide the card number depending on how you chose to tokenize your card data. To run a Reactor, an Application needs token:use permission granted for any tokens that are detokenized. Click here to create one. In each of the following examples, on a successful request you will be returned a React Response which contains data returned from your executed Reactor. { \"tokens\": \"&lt;Tokenized Data Returned from the Reactor&gt;\", \"raw\": \"&lt;Raw Output Returned from the Reactor&gt;\" } . Use a Card Number Token . In the following example we have opted to store the card number within a Card Number Token. We will include a detokenization expression containing this token in the Reactor request, which will result in the original token data being inserted within the request sent to the Reactor. curl \"https://api.basistheory.com/reactors/&lt;reactor_id&gt;/react\" \\ -H \"BT-API-KEY: &lt;application_api_key&gt;\" \\ -X \"POST\" \\ -d '{ \"args\": { \"card\": { \"number\": \"{{&lt;card_number_token_id&gt;}}\" } } }' . Use a Card Token . In the following example we have opted to store the card data within a Card Token. Since the data within a Card token contains a number property, we can simply detokenize the entire Card token into the card argument, which will cause the token’s entire JSON object data to be inserted into the card node. curl \"https://api.basistheory.com/reactors/&lt;reactor_id&gt;/react\" \\ -H \"BT-API-KEY: &lt;application_api_key&gt;\" \\ -X \"POST\" \\ -d '{ \"args\": { \"card\": \"{{&lt;card_token_id&gt;}}\" } }' . Since Reactors validate the provided args against the declared request parameters and drop any undeclared arguments, the additional properties (expiration_month, expiration_year, cvc) on the Card token object will be automatically removed from the request. Use a Card Token with a JSON Path Transformation . In the following example we have again opted to store the card data within a Card Token. However, in this example we will pass only the number property from the Card token by using the json filter to project out the number property. curl \"https://api.basistheory.com/reactors/&lt;reactor_id&gt;/react\" \\ -H \"BT-API-KEY: &lt;application_api_key&gt;\" \\ -X \"POST\" \\ -d '{ \"args\": { \"card\": { \"number\": \"{{ &lt;card_token_id&gt; | json: '$.number' }}\" } } }' . ",
    "url": "https://developers.basistheory.com/guides/use-token-data-in-reactors/#use-your-new-reactor",
    "relUrl": "/guides/use-token-data-in-reactors/#use-your-new-reactor"
  },"150": {
    "doc": "Use U.S. Bank Accounts without touching them",
    "title": "Use U.S. Bank Accounts without touching them",
    "content": "This guide will quickly enable you to be compliant with new Nacha Encryption rules. Safely storing bank account data in a way that enables your entire organization to safely use, is no small feat. It takes a strong encryption pattern, including a KMS, key rotation, multiple encryption keys, access controls, and so much more. In this guide, we will show you how to quickly collect and secure your customers’ U.S. Bank Account information with Basis Theory. You’ll learn how to collect the data using our Elements, toknize the information, and use our Serverless Reactor platform to communicate with Spreedly to obtain a Payment Method. If you’d like to follow along with this guide jump right into our sample app - Find it here! . | Add Elements to your website | Create a Bank token from your new Elements | Set up a Spreedly Reactor | Using your new Reactor | Wrap up | . ",
    "url": "https://developers.basistheory.com/guides/use-us-bank-accounts-without-touching-them/",
    "relUrl": "/guides/use-us-bank-accounts-without-touching-them/"
  },"151": {
    "doc": "Use U.S. Bank Accounts without touching them",
    "title": "Add Elements to your website",
    "content": "To start, you’ll need a new Public Application with the token:create permission granted to the /bank/ container. Click here to create one. First, add two new div tag elements to your HTML. These will serve as a place to attach two separate Element tags for both Routing Number and Bank Account. &lt;div class=\"row row-input\" id=\"routing_number\"&gt;&lt;/div&gt; &lt;div class=\"row row-input\" id=\"account_number\"&gt;&lt;/div&gt; . Second, you’ll need to add the following javascript code to your application to mount each element: . await BasisTheory.init(ELEMENTS_KEY, { elements: true, }); let routingNumber = BasisTheory.createElement('text', { ...options, targetId: 'routingNumber', placeholder: 'Routing Number', 'aria-label': 'Routing Number', }); let accountNumber = BasisTheory.createElement('text', { ...options, targetId: 'accountNumber', placeholder: 'Account Number', 'aria-label': 'Account Number', }); await routingNumber.mount('#routing_number'); await accountNumber.mount('#account_number'); . Finally, you’ll see two new Elements appear on your page. Next, we will tokenize the data entered into them! . ",
    "url": "https://developers.basistheory.com/guides/use-us-bank-accounts-without-touching-them/#add-elements-to-your-website",
    "relUrl": "/guides/use-us-bank-accounts-without-touching-them/#add-elements-to-your-website"
  },"152": {
    "doc": "Use U.S. Bank Accounts without touching them",
    "title": "Create a Bank token from your new Elements",
    "content": "Creating tokens with our Elements is as easy as if you’re passing raw text. To create a Bank token, you’ll just need to pass the token’s type (bank) and the Element references from Step 1 into the tokens.create method. const token = await BasisTheory.tokens.create({ type: 'bank', data: { routing_number: routingNumber, account_number: accountNumber } }); . You now have a new Bank token assigned to token - typically the id and mask of this token is stored within your database which allows you to read back the data at a later date. ",
    "url": "https://developers.basistheory.com/guides/use-us-bank-accounts-without-touching-them/#create-a-bank-token-from-your-new-elements",
    "relUrl": "/guides/use-us-bank-accounts-without-touching-them/#create-a-bank-token-from-your-new-elements"
  },"153": {
    "doc": "Use U.S. Bank Accounts without touching them",
    "title": "Set up a Spreedly Reactor",
    "content": "Configure one of our pre-built Reactor Formulas, enabling you to quickly exchange raw bank data for a processor token (e.g. Spreedly - Bank). To set up a Reactor, head over to our Portal and set up a new Spreedly Reactor. If you’re looking for step-by-step guide on how to set up a Reactor, head over to our guide. ",
    "url": "https://developers.basistheory.com/guides/use-us-bank-accounts-without-touching-them/#set-up-a-spreedly-reactor",
    "relUrl": "/guides/use-us-bank-accounts-without-touching-them/#set-up-a-spreedly-reactor"
  },"154": {
    "doc": "Use U.S. Bank Accounts without touching them",
    "title": "Using your new Reactor",
    "content": "To use your new Spreedly Reactor, you’ll need a Private Application with the token:use and token:create permissions granted to the /bank/ container. Click here to create one. Once you’ve created your Spreedly Reactor, use the reactor_id and your Bank token’s ID to exchange for a new Spreedly Payment Method token, enabling you to charge your customer. const reactorResponse = await bt.reactors.react(REACTOR_ID, { args: { card: `{{${token.id}}}` } }); return reactorResponse; . With your Spreedly Payment Method in hand, you can store this within your own platform and avoid becoming dependent on Basis Theory for your future transactions. As soon as you need a new Payment Method, just call the /react endpoint for that reactor with your token id, and you’ll have a newly attached token. ",
    "url": "https://developers.basistheory.com/guides/use-us-bank-accounts-without-touching-them/#using-your-new-reactor",
    "relUrl": "/guides/use-us-bank-accounts-without-touching-them/#using-your-new-reactor"
  },"155": {
    "doc": "Use U.S. Bank Accounts without touching them",
    "title": "Wrap up",
    "content": "Now that you understand the basics of using our Elements and Bank tokens to collect and charge a customer, you have the ability to easily use your encrypted Bank token in any way you’d like: . | Use our Serverless Reactors to create an ACH file (if you’re looking to do this, reach out!) | Quickly begin securing and using raw bank data yourself with our API | Interact with any other banking service you can imagine (e.g. Dwolla, Plaid, etc) | Style our Elements to look exactly like your own application | . ",
    "url": "https://developers.basistheory.com/guides/use-us-bank-accounts-without-touching-them/#wrap-up",
    "relUrl": "/guides/use-us-bank-accounts-without-touching-them/#wrap-up"
  },"156": {
    "doc": "Use U.S. Bank Accounts without touching them",
    "title": "See it in action",
    "content": "Want to experience the sandbox yourself? Check it out here. ",
    "url": "https://developers.basistheory.com/guides/use-us-bank-accounts-without-touching-them/#see-it-in-action",
    "relUrl": "/guides/use-us-bank-accounts-without-touching-them/#see-it-in-action"
  },"157": {
    "doc": "Use Token Data in HTTP Requests",
    "title": "Use Token Data in HTTP Requests",
    "content": "In this guide, we will walk through how to use the Proxy to send an outbound HTTP request containing sensitive detokenized data. We will be leveraging the third party service https://httpbin.org/ as our external destination API. HTTPBin is a free service that will accept any input request and respond with information about the request it received. This will allow us to inspect the manipulated request that was forwarded from the Proxy to the destination API. If you would like to learn more about the Basis Theory Proxy first, or how this product can help you meet your security and compliance needs, check out What is the Proxy? before continuing. | Prerequisites . | Application Setup | Create a Token | . | Create the Proxy Request | Send the Proxy Request Containing Detokenized Values | . ",
    "url": "https://developers.basistheory.com/guides/use-token-data-in-http-requests/",
    "relUrl": "/guides/use-token-data-in-http-requests/"
  },"158": {
    "doc": "Use Token Data in HTTP Requests",
    "title": "Prerequisites",
    "content": "Application Setup . We will be creating and proxying tokens that contain PCI data in this example. First, we need to ensure we have a Private Application configured that has token:create and token:use permissions. We will be using the API Key associated with this application in all HTTP requests below. Click here to create it. Create a Token . Next, we will create a card_number token containing a credit card number we wish to secure with Basis Theory. curl \"https://api.basistheory.com/tokens\" \\ -H \"BT-API-KEY: key_NS21v84n7epsSc5WzoFjM6\" \\ -H \"Content-Type: application/json\" \\ -X \"POST\" \\ -d '{ \"type\": \"card_number\", \"data\": \"6011111111111117\" }' . This responds with the created token: . { \"id\": \"a70f8701-8b65-476b-ac0a-21bcd7d943d5\", \"type\": \"card_number\", \"data\": \"XXXXXXXXXXXX1117\", ... } . We will be using the id of this token below to build a request to the Proxy. ",
    "url": "https://developers.basistheory.com/guides/use-token-data-in-http-requests/#prerequisites",
    "relUrl": "/guides/use-token-data-in-http-requests/#prerequisites"
  },"159": {
    "doc": "Use Token Data in HTTP Requests",
    "title": "Create the Proxy Request",
    "content": "In this example, we will be working with a hypothetical third party HTTP API that requires credit card information as input. This API will be available at https://httpbin.org/anything and it expects an HTTP POST request with a request body of the form: . { \"firstName\": &lt;string&gt;, \"lastName\": &lt;string&gt;, \"creditCardNumber\": &lt;string&gt;, \"expirationDate\": &lt;string&gt; } . Our hypothetical source system will be storing plaintext first names, last names, and expiration dates of card numbers, as these fields are considered non-sensitive. However, in order to minimize the compliance and security risk of our application, we do not want our application to store or even interact with raw credit card numbers when building this HTTP request. Instead, we will send a request to the Basis Theory Proxy which contains the non-sensitive data fields and the id of the card_number token we wish to include in the request. { \"firstName\": \"John\", \"lastName\": \"Doe\", \"creditCardNumber\": \"{{a70f8701-8b65-476b-ac0a-21bcd7d943d5}}\", \"expirationDate\": \"10/2024\" } . The expression {{a70f8701-8b65-476b-ac0a-21bcd7d943d5}} within the request will be identified by the Proxy, and the raw credit card number represented by this token will be substituted in its place. ",
    "url": "https://developers.basistheory.com/guides/use-token-data-in-http-requests/#create-the-proxy-request",
    "relUrl": "/guides/use-token-data-in-http-requests/#create-the-proxy-request"
  },"160": {
    "doc": "Use Token Data in HTTP Requests",
    "title": "Send the Proxy Request Containing Detokenized Values",
    "content": "In order to send this request payload into the Basis Theory Proxy a few additional pieces of information are required as HTTP headers: . | BT-API-KEY: the API key of the Basis Theory application we created earlier | BT-PROXY-URL: the destination url to which the request should be forwarded (https://httpbin.org/anything) | BT-PROXY-KEY: the key of the pre-configured proxy to use for this request | . curl \"https://api.basistheory.com/proxy\" \\ -H \"BT-API-KEY: key_NS21v84n7epsSc5WzoFjM6\" \\ -H \"BT-PROXY-URL: https://httpbin.org/anything\" \\ -H \"Content-Type: application/json\" \\ -X \"POST\" \\ -d '{ \"firstName\": \"John\", \"lastName\": \"Doe\", \"creditCardNumber\": \"{{a70f8701-8b65-476b-ac0a-21bcd7d943d5}}\", \"expirationDate\": \"10/2024\" }' . This sends the request through the Proxy, which transforms the request before forwarding it onto the destination service at HTTPBin. HTTPBin returns the following response describing the request that it received, and this response is forwarded back through the proxy (some information is redacted for brevity): . { \"data\": \"{ \\\"firstName\\\": \\\"John\\\", \\\"lastName\\\": \\\"Doe\\\", \\\"creditCardNumber\\\": \\\"6011111111111117\\\", \\\"expirationDate\\\": \\\"10/2024\\\" }\", \"headers\": { ... \"Content-Type\": \"application/json\", \"Host\": \"httpbin.org\", \"X-Forwarded-Host\": \"api.basistheory.com\", \"X-Forwarded-Tlsversion\": \"1.2\", ... }, \"json\": { \"creditCardNumber\": \"6011111111111117\", \"expirationDate\": \"10/2024\", \"firstName\": \"John\", \"lastName\": \"Doe\" }, \"method\": \"POST\", ... } . As we can see from this response, the request received by the destination service included the original raw credit card number that had been tokenized with Basis Theory. The other non-sensitive data fields that were provided in plaintext were forwarded in the request without modification. This was just a basic example of what you can accomplish using the Proxy. If you’re interested in some of the more advanced proxying features, check out our docs on the Proxy or Detokenization to learn more! . ",
    "url": "https://developers.basistheory.com/guides/use-token-data-in-http-requests/#send-the-proxy-request-containing-detokenized-values",
    "relUrl": "/guides/use-token-data-in-http-requests/#send-the-proxy-request-containing-detokenized-values"
  },"161": {
    "doc": "Token Containers",
    "title": "What are Token Containers?",
    "content": "Tokens can be logically grouped into Containers to segment Tokens within a Tenant. Containers can be leveraged to construct fine-grained access control policies by attaching one or more Access Rules to an Application. Each Access Rule can be scoped to a specific Container of tokens, allowing you to grant an Application permission to interact with only a subset of tokens within your Tenant. A Container is represented by a hierarchical path, which is conceptually similar to directories in a UNIX filesystem. Container names must start and end with a /, and the root Container is denoted by /. Container names may include any alphanumeric characters, -, or _, and can contain an arbitrary number of nested sub-containers. You have complete control to customize your Container hierarchy to meet your unique data governance requirements. If containers is not specified when creating a Token, default Containers will be assigned based on the Token Type. Default containers are based on NIST defined data classifications and impact levels, e.g. /pci/high/ for card tokens, or /general/high/ for general tokens of type token. An existing Token’s Containers can be modified through the Update Token endpoint, provided that the Application performing the update has token:update permission to both the source and destination Containers. ",
    "url": "https://developers.basistheory.com/concepts/what-are-token-containers/#what-are-token-containers",
    "relUrl": "/concepts/what-are-token-containers/#what-are-token-containers"
  },"162": {
    "doc": "Token Containers",
    "title": "Common Use Cases",
    "content": "Segmenting by data classification . To segment tokens by data classification, you could organize your tokens into the following containers: . | /pci/ | /general/ | /pii/ | . This would enable you to create Applications that are only granted access to a specific classification of data. For example, a billing system could be granted access to only the /pci/ container, while a customer service system could only be granted access to the /pii/ container in order to support user account management. Segmenting by customer . To segment tokens by customer, you could organize your tokens into the following containers: . | /customer-1/ | /customer-2/ | /customer-3/ | . This would enable you to create Applications that are only granted access to one or more specific customers’ data. Tokens may also be further segmented within each customer’s container, as needed. For example, you could partition a customer’s data by classification, say between payments related Tokens and Tokens used to store a customer’s contact information. You could achieve this by further dividing Tokens into the sub-containers: . | /customer-2/pci/ | /customer-2/pii/ | . ",
    "url": "https://developers.basistheory.com/concepts/what-are-token-containers/#common-use-cases",
    "relUrl": "/concepts/what-are-token-containers/#common-use-cases"
  },"163": {
    "doc": "Token Containers",
    "title": "Token Containers",
    "content": " ",
    "url": "https://developers.basistheory.com/concepts/what-are-token-containers/",
    "relUrl": "/concepts/what-are-token-containers/"
  },"164": {
    "doc": "Monthly Active Tokens",
    "title": "What are Monthly Active Tokens?",
    "content": "Monthly Active Tokens (MATs) are the primary metric that drives Basis Theory’s pricing model. In this guide, we’ll walk through how MATs are defined and some nuances around how they are counted. We will also explore how MATs are used to determine your monthly Basis Theory invoice. ",
    "url": "https://developers.basistheory.com/concepts/what-are-mats/#what-are-monthly-active-tokens",
    "relUrl": "/concepts/what-are-mats/#what-are-monthly-active-tokens"
  },"165": {
    "doc": "Monthly Active Tokens",
    "title": "How are MATs defined?",
    "content": "A MAT is any token that has been interacted with in a given calendar month via one of the following operations: . Create . When a token is created, it will be counted as a MAT for the current month. If the tokenize API endpoint is used to bulk create several tokens in one request, all created tokens are counted as separate MATs. Any tokens that are created in the tokenize output of a Reactor will also be counted as MATs. Read . Whenever a token is retrieved from the API it is counted as a MAT. This could include: . | Retrieving a single token by id - the returned token will be counted as a MAT. | Retrieving a list of tokens - any tokens returned from the list API will be counted as MATs. | Searching tokens - any tokens returned from the search API will be counted as MATs. | . For paginated API endpoints, only the tokens included in the returned page(s) are counted as MATs. Tokens that match your search criteria that are contained within other non-fetched pages will not be counted as MATs. Use . Any token that is used within a Reactor or the Proxy will be counted as a MAT. This includes any tokens that were Detokenized within a Reactor or Proxy request. A token is only counted as a Monthly Active Token if it has been interacted with through the Basis Theory API. Tokens that are viewed or interacted with through the Portal are not counted as MATs. ",
    "url": "https://developers.basistheory.com/concepts/what-are-mats/#how-are-mats-defined",
    "relUrl": "/concepts/what-are-mats/#how-are-mats-defined"
  },"166": {
    "doc": "Monthly Active Tokens",
    "title": "How are MATs counted?",
    "content": "MATs are counted separately per Tenant and are not aggregated across your Tenants. If you own more than one Basis Theory Tenant, e.g. for multiple environments to support your SDLC process, then each tenant accrues MATs and billing charges according to its own usage. Interacting with a given token more than once does not increase your MAT count or incur additional charges - each token is counted as a MAT at most once per month. For example, if in a given month you create a token, read it several times, and use this token within a Reactor and the Proxy, then this token will only be counted as a single MAT for the month. Likewise, detokenizing a single token multiple times within a Reactor or Proxy request, for example to select multiple properties from a token using a JSON Path transformation, will only cause that token to be counted as a single MAT. Deleting a token does not cause it to be counted as a MAT. However, if you previously interacted with a token causing it to become counted as a MAT, then delete the token in the same month, the token is still counted as a MAT for that month even after deleting it. The monthly period in which MATs accumulate is based on UTC time, and each Tenant’s MAT counts are reset to 0 at the start of a new month. A token being counted as a MAT in one month has no impact on it being counted as a MAT again in another month - a given token can be counted as a MAT in consecutive months if it has been interacted with in both months. ",
    "url": "https://developers.basistheory.com/concepts/what-are-mats/#how-are-mats-counted",
    "relUrl": "/concepts/what-are-mats/#how-are-mats-counted"
  },"167": {
    "doc": "Monthly Active Tokens",
    "title": "How is my monthly invoice calculated?",
    "content": "Your invoice will be calculated based on the specific terms of your plan - either the standard Developer plan or a Custom plan. For the Developer plan, you are allowed 1,000 free MATs every month before any charges will be incurred. If a Tenant exceeds 1,000 MATs, you will be billed at a rate of $0.10/MAT for any MATs over this free amount. For example, if you have a Tenant that has accrued 1,200 MATs in a month, you will be billed for 200 MATs and will incur a charge of 200 * $0.10 = $20.00 for the month. Once a Tenant exceeds the 1,000 free MATs, you will be prompted to enter a payment method to continue using Basis Theory. In order to facilitate your evaluation of Basis Theory, you will not be immediately blocked from continued usage of Basis Theory’s services, and will have a short grace period to enter your payment details while continuing evaluation. ",
    "url": "https://developers.basistheory.com/concepts/what-are-mats/#how-is-my-monthly-invoice-calculated",
    "relUrl": "/concepts/what-are-mats/#how-is-my-monthly-invoice-calculated"
  },"168": {
    "doc": "Monthly Active Tokens",
    "title": "Are there usage limits to the monthly active tokens?",
    "content": "There is a limit of 5 interactions per MAT per month. Our billing is designed to be simple for almost every use-case for using our platform. In some situations more than 5 interactions per MAT in a month are required. Contact us for alternate plans available when this limit isn’t enough. Are you interested in using Basis Theory in production? Please contact us to discuss a Custom plan with volume discount pricing tailored to your organization’s needs. ",
    "url": "https://developers.basistheory.com/concepts/what-are-mats/#are-there-usage-limits-to-the-monthly-active-tokens",
    "relUrl": "/concepts/what-are-mats/#are-there-usage-limits-to-the-monthly-active-tokens"
  },"169": {
    "doc": "Monthly Active Tokens",
    "title": "Monthly Active Tokens",
    "content": " ",
    "url": "https://developers.basistheory.com/concepts/what-are-mats/",
    "relUrl": "/concepts/what-are-mats/"
  },"170": {
    "doc": "Reactors",
    "title": "Reactors",
    "content": "A Reactor is a serverless compute service allowing Node.js code hosted in Basis Theory to be executed against your tokens completely isolated away from your application and systems. Reactors are invokable from any system that has the ability to make HTTPS requests and access the internet. ",
    "url": "https://developers.basistheory.com/concepts/what-are-reactors/",
    "relUrl": "/concepts/what-are-reactors/"
  },"171": {
    "doc": "Reactors",
    "title": "How It Works",
    "content": "Reactors are serverless function runtimes, similar to AWS Lambda, Azure Functions, or Cloudflare Workers - except your applications, systems, and infrastructure never touches the sensitive plaintext data. ",
    "url": "https://developers.basistheory.com/concepts/what-are-reactors/#how-it-works",
    "relUrl": "/concepts/what-are-reactors/#how-it-works"
  },"172": {
    "doc": "Reactors",
    "title": "Reactor Formulas",
    "content": "Using a Reactor starts with the code you’d like to execute within your system, this code template is referred to as a Reactor Formula. When creating a Reactor Formula you will define the code, expected request parameters, and any up-front configuration - like secrets - required to execute your function. Find an exhaustive list of all configuration options in our Reactor Formula API Reference. Formulas provide two different response types, giving the flexibility of securing data or returning it as a raw response: . | tokenize . | Any object passed will be tokenized. | . | raw . | Any object passed will be returned from the HTTP request that invoked the Reactor. | . | . module.exports = async function (req) { // code to execute return { tokenize: { bar: 'secret' // will be tokenized }, raw: { foo: 'plaintext' // will be returned in plaintext } }; }; . Quickstart hint: Find a list of our fully compliant and maintained Official Reactor Formulas from within our Portal . ",
    "url": "https://developers.basistheory.com/concepts/what-are-reactors/#reactor-formulas",
    "relUrl": "/concepts/what-are-reactors/#reactor-formulas"
  },"173": {
    "doc": "Reactors",
    "title": "Creating a Reactor",
    "content": "Reactors are created with our Create Reactor endpoint. Once configured each Reactor can be invoked - executing the formula it has been configured with. Creating a new Reactor is as simple as passing in the configuration and Formula to be invoked. curl \"https://api.basistheory.com/reactors\" \\ -H \"BT-API-KEY: &lt;API_KEY_HERE&gt;\" \\ -H \"Content-Type: application/json\" \\ -X \"POST\" \\ -d '{ \"name\": \"My First Reactor\", \"configuration\": { \"SERVICE_API_KEY\": \"key_abcd1234\" }, \"formula\": { \"id\": \"17069df1-80f4-439e-86a7-4121863e4678\" } }' . We encrypt and store each configuration setting in our secure PCI Level 1 and SOC2 environment. ",
    "url": "https://developers.basistheory.com/concepts/what-are-reactors/#creating-a-reactor",
    "relUrl": "/concepts/what-are-reactors/#creating-a-reactor"
  },"174": {
    "doc": "Reactors",
    "title": "Invoking a Reactor",
    "content": "Reactors may be invoked by an Application with token:use permission, which enables the Reactor to detokenize tokens provided in the request args. It is recommended that you restrict which tokens a Reactor can detokenize by only granting token:use permission on the most-specific container of tokens that is required. curl \"https://api.basistheory.com/reactors/5b493235-6917-4307-906a-2cd6f1a90b13/react\" \\ -H \"BT-API-KEY: key_N88mVGsp3sCXkykyN2EFED\" \\ -X \"POST\" \\ -d '{ \"args\": { \"card\": \"\", \"customer_id\": \"myCustomerId1234\" } }' . ",
    "url": "https://developers.basistheory.com/concepts/what-are-reactors/#invoking-a-reactor",
    "relUrl": "/concepts/what-are-reactors/#invoking-a-reactor"
  },"175": {
    "doc": "Reactors",
    "title": "Common Use Cases",
    "content": "Call a 3rd party . Depending on how complex your use case is a Reactor may provide you with an excellent opportunity to mutate data before forwarding it onto a 3rd Party. In the below example, we call httpbin.org (an echo service) with the last 4 characters of our token: . module.exports = async function (req) { const fetch = require('node-fetch'); const { customer_id } = req.args; const last4 = customer_id.substring(-4); const response = await fetch('https://httpbin.org/post', {method: 'POST', body: last4}); const raw = await resp.json() return { raw, }; }; . Create a pdf document . Creating documents out of sensitive data is a primary need for businesses today, especially in fintech where you need to create and submit 1099s for many businesses: . module.exports = async function (req) { const fetch = require('node-fetch'); const PDFDocument = require('pdfkit'); const { token: { data } } = req.args; let doc = new PDFDocument; doc.fontSize(8) .text(`Some token data on a pdf: ${data}`, 1, 1); doc.end(); //Send or upload file to your partner const response = await fetch('https://httpbin.org/post', {method: 'POST', body: doc}); const raw = await resp.json() return { raw, }; }; . Generate a text file and send to an SFTP server . Many legacy business process still rely heavily on comma delimited files (CSV), tab delimited files or space-delimited files to transport data between companies, typically using SFTP servers as the endpoint of this data. For example, engaging with partner banks with ACH files requires you to format your file correctly and drop it on to an SFTP server. module.exports = async function (req) { var fs = require(\"fs\"); var {Client} = require('ssh2'); const { token: { { prop1, prop2, prop3 } } } = req.args; const { host, username, password } = req.configuration; var connSettings = { host, port: 22, username, password }; var conn = new Client(); return new Promise((resolve) =&gt; conn.on('ready', function() { conn.sftp(function(err, sftp) { var bufferStream = new require('stream').PassThrough(); bufferStream.end(Buffer.from(`${prop1},${prop2},${prop3}`, \"utf-8\")); const writeStream = sftp.createWriteStream( \"test.csv\"); writeStream.on('close',function () { res.json({success: true}); resolve(); }); bufferStream.pipe(writeStream); }); }).connect(connSettings)); }; . Import file from a partner . When you need to process files of sensitive data without it touching your systems, use a Reactor to desensitize a file before forwarding it on to your systems for your own logic: . module.exports = async function (req) { const { BasisTheory } = require('@basis-theory/basis-theory-js'); const { fileString } = req.args; // \"name,ssn\\nTheory,555445555\" const { BT_API_KEY } = req.configuration; const bt = await new BasisTheory().init(BT_API_KEY); const rows = fileString.split(\"\\n\").map(r =&gt; r.split(\",\")); await Promise.all(rows.slice(1).map(row =&gt; { return bt.tokens.create({ type: 'social_security_number', data: row[1], }).then(token =&gt; row[1] = token.id); })); const desensitizedFile = rows.map(row =&gt; row.join(\",\")).join(\"\\n\"); res.json({ raw: desensitizedFile}); // \"name,ssn\\nTheory,14f5c8d4-3e84-4185-96ac-fac6386614dc\" }; . Anything you can imagine . When our templates and examples aren’t enough, we enable you to build anything you want to with our Reactors. Start with a blank function like the one below and solve any business problem with the data you need: . module.exports = async function (req) { const { tokens } = req.args; // Anything you can dream up 💭 return { tokenize: { foo: \"bar\" }, // tokenize data raw: { foo: \"bar\"} // return any data }; }; . ",
    "url": "https://developers.basistheory.com/concepts/what-are-reactors/#common-use-cases",
    "relUrl": "/concepts/what-are-reactors/#common-use-cases"
  },"176": {
    "doc": "Reactors",
    "title": "FAQ:",
    "content": "When do I use a Reactor? . When you’re required to write your own code to solve more complex problems - for example when needing to manipulate the data, create a document, or import a file from a partner. When would I use the Proxy instead of a Reactor? . When making a simple HTTP request, a simpler implementation can be created using the Proxy. What does the development lifecycle look like for building Reactors? . Each Reactor runs a single function which can be scoped, coded, and tested all within your normal development tooling and lifecycles. Code written and pushed to your own Github repositories can be used to create new Reactor Formulas using our Terraform Provider or API integrations. Can we run the reactor code locally to test? . Absolutely, each function you write for your Reactors can be run and tested locally. This code can be treated exactly the same as the existing application code you’re deploying to other infrastructure. Is there a cold start spin-up time for Reactors? . Our Reactors are designed to be always hot - which allows for fast execution with little spin-up time. Is there a concept of “sandbox” Reactors? . Our Reactors follow the same development lifecycle as the rest of our platform, allowing you to create a new Tenant to handle any testing of your platform from your staging or development environments. What are the IP addresses for BT? . We have the list of our public IP addresses here. How can Reactors reduce the PCI compliance scope of my application? . Using our Reactors allows you to execute code against any PCI classified data, enabling your infrastructure to stay out of PCI compliance. ",
    "url": "https://developers.basistheory.com/concepts/what-are-reactors/#faq",
    "relUrl": "/concepts/what-are-reactors/#faq"
  },"177": {
    "doc": "Tokens",
    "title": "Tokens",
    "content": "Tokens are the core of the Basis Theory platform, built to enable companies to remove the need to store sensitive data while granting the flexibility they need to grow and operate their businesses. Tokens are a reference to the sensitive data that’s stored in our system. Our tokens enable you to pass raw data to our platform, and we will handle keeping it safe for you while returning a non-sensitive token identifier for you to reference from your systems. | How is the data stored? | What types of data can I store? | What operations can I do with tokens? | What are the capabilities of a token? . | Aliasing | Fingerprinting | Masking | Containers | Time to Live (TTL) | Auditing | Search Indexes | Deduplication | Metadata | Associations | . | Use Cases . | Tokenize Credit Cards | Tokenize Bank Data | Tokenize User Data | Tokenize Credentials | . | . ",
    "url": "https://developers.basistheory.com/concepts/what-are-tokens/",
    "relUrl": "/concepts/what-are-tokens/"
  },"178": {
    "doc": "Tokens",
    "title": "How is the data stored?",
    "content": "When you tokenize data with Basis Theory, we will carefully encrypt the data with NIST and FIPS-compliant encryption algorithms. We ensure the data has been encrypted with a one-time use encryption key, which is then encrypted again and stored within our platform. This foundational encryption ensures your data is uniquely encrypted each time a new token is created. We will never mix our customers’ encryption keys. Your keys are only used for your data, period. ",
    "url": "https://developers.basistheory.com/concepts/what-are-tokens/#how-is-the-data-stored",
    "relUrl": "/concepts/what-are-tokens/#how-is-the-data-stored"
  },"179": {
    "doc": "Tokens",
    "title": "What types of data can I store?",
    "content": "You can store any primitive, complex, or unstructured data with our token type. This can enable you to store a user record, a simple social security number, or the contents of a file. There are token types available, such as card and bank types, to simplify your integration by offering pre-configured capabilities described in this page. If you are interested in more token types, please reach out. ",
    "url": "https://developers.basistheory.com/concepts/what-are-tokens/#what-types-of-data-can-i-store",
    "relUrl": "/concepts/what-are-tokens/#what-types-of-data-can-i-store"
  },"180": {
    "doc": "Tokens",
    "title": "What operations can I do with tokens?",
    "content": "You can manage the full lifecycle of all of your tokens. This includes creating, updating, reading, detokenizing, searching, and deleting tokens. Basis Theory offers the ability to also create tokens in bulk via the tokenize API endpoint. This endpoint provides a way to create multiple tokens while preserving the format of your request. You can also make use of the token time to live (TTL) capability to expire your tokenized data. ",
    "url": "https://developers.basistheory.com/concepts/what-are-tokens/#what-operations-can-i-do-with-tokens",
    "relUrl": "/concepts/what-are-tokens/#what-operations-can-i-do-with-tokens"
  },"181": {
    "doc": "Tokens",
    "title": "What are the capabilities of a token?",
    "content": "Our token specification enables you to transform your data to optimize for storage, readability, searching, and permissions. Basis Theory utilizes Liquid template expressions to enable full control over all parts of your tokenized data. ",
    "url": "https://developers.basistheory.com/concepts/what-are-tokens/#what-are-the-capabilities-of-a-token",
    "relUrl": "/concepts/what-are-tokens/#what-are-the-capabilities-of-a-token"
  },"182": {
    "doc": "Tokens",
    "title": "Aliasing",
    "content": "In some scenarios, you need your token identifier to be in a specific format. This may be because you have to pass existing validation requirements, have an existing data format or database schema that is hard to change. Aliasing provides a simple way to customize the format of your token identifier to meet your needs. Let’s assume you have a social security number you are storing and you want to alias the token identifier to match the SSN format: . Request . { \"id\": \"{{ data | alias_preserve_format }}\", \"type\": \"token\", \"data\": \"123-45-6789\" } . Response . { \"id\": \"384-28-3948\", \"type\": \"token\" } . Another example may be that you want to format your email and retain the domain on the email while preserving the length of the email identifier so you can search for an instance of the email domain in your database without exposing the actual email addresses: . Request . { \"id\": \"{{ data | split: '@' | first | alias_preserve_length }}@{{ data | split: '@' | last }}\", \"type\": \"token\", \"data\": \"johndoe@basistheory.com\" } . Response . { \"id\": \"difkelk@basistheory.com\", \"type\": \"token\" } . ",
    "url": "https://developers.basistheory.com/concepts/what-are-tokens/#aliasing",
    "relUrl": "/concepts/what-are-tokens/#aliasing"
  },"183": {
    "doc": "Tokens",
    "title": "Fingerprinting",
    "content": "Fingerprinting provides a way to correlate multiple tokens together that contain the same data without needing access to the underlying data. Creating multiple tokens with the same token type, data, and fingerprint expression will result in the same fingerprint. This can be useful for correlating purchases with the same credit card for multiple members of the same household or helping with master data management of multiple user accounts. By default, all tokens are fingerprinted with the contents of the data property using the default fingerprint expression of {{ data | stringify }}, however you can customize this fingerprint expression to meet your needs of what should uniquely identify a token. In the following example, we will create a token with user data, but we want to fingerprint on the email address: . Request . { \"type\": \"token\", \"data\": { \"first_name\": \"John\", \"last_name\": \"Doe\", \"email_address\": \"johndoe@basistheory.com\" }, \"fingerprint_expression\": \"{{ data.email_address }}\" } . Response . { \"id\": \"1e7f0dde-5442-40ab-b244-5e02bcd5f86d\", \"type\": \"token\", \"fingerprint\": \"PH12E7vY7HfRTdGVUDeLzRcP8\", \"fingerprint_expression\": \"{{ data.email_address }}\" } . In the above example, if another token is created with the email_address of johndoe@basistheory.com, the same fingerprint value of PH12E7vY7HfRTdGVUDeLzRcP8 will be returned. If a token with a different email_address is created, a different fingerprint value will be returned. ",
    "url": "https://developers.basistheory.com/concepts/what-are-tokens/#fingerprinting",
    "relUrl": "/concepts/what-are-tokens/#fingerprinting"
  },"184": {
    "doc": "Tokens",
    "title": "Masking",
    "content": "Masking is a way to securely and compliantly reveal parts of sensitive data. This is useful for revealing the last 4 digits of a credit card number to a customer during a checkout process or the last part of a social security number for a customer service representative to verify account ownership. Masks are computed based on the current value of the token data. Updating the token will change what masked data is returned. A scenario where masking is useful is in enabling customer service representatives to verify the account information for a customer using the last four of a social security number without having access to the full SSN. In this example, we will mask customer data so representatives can securely and compliantly view only part of the customer record: . Request . { \"type\": \"token\", \"data\": { \"first_name\": \"John\", \"last_name\": \"Doe\", \"social_security_number\": \"111-22-3333\", \"email_address\": \"johndoe@basistheory.com\" }, \"mask\": { \"first_name\": \"{{ data.first_name }}\", \"last_name\": \"{{ data.last_name | slice: 0 }}.\", \"social_security_number\": \"{{ data.social_security_number | reveal_last: 4 }}\", \"email_address\": \"{{ data.email_address | split: '@' | last }}\" } } . Response . { \"id\": \"ae164fcd-227d-40ce-b7ec-435faa6a8c73\", \"type\": \"token\", \"data\": { \"first_name\": \"John\", \"last_name\": \"D.\", \"social_security_number\": \"XXX-XX-3333\", \"email_address\": \"basistheory.com\" }, \"mask\": { \"first_name\": \"{{ data.first_name }}\", \"last_name\": \"{{ data.last_name | slice: 0 }}.\", \"social_security_number\": \"{{ data.social_security_number | reveal_last: 4 }}\", \"email_address\": \"{{ data.email_address | split: '@' | last }}\" } } . ",
    "url": "https://developers.basistheory.com/concepts/what-are-tokens/#masking",
    "relUrl": "/concepts/what-are-tokens/#masking"
  },"185": {
    "doc": "Tokens",
    "title": "Containers",
    "content": "Containers enable you to logically group Tokens and segment data within a Tenant, enabling you to organize Tokens based on your unique data governance strategy. By default, tokens are placed into containers based on NIST defined data classifications and impact levels. Containers allow you to grant scoped access to subsets of Tokens, limiting the amount of data accessible by your internal systems. Access Controls can be used in conjunction with Containers to allow some systems access to highly confidential data while restricting access to only masked or redacted Tokens from other systems. For example, we may want to store a customer’s social security number and only provide access to the last 4 digits of the SSN to our customer service team. ",
    "url": "https://developers.basistheory.com/concepts/what-are-tokens/#containers",
    "relUrl": "/concepts/what-are-tokens/#containers"
  },"186": {
    "doc": "Tokens",
    "title": "Time to Live (TTL)",
    "content": "The time to live token capability provides the ability to expire your token data. This is useful in scenarios such as an expiring credit card, to share temporary credentials for system or user access, or meeting data retention policies. This example shows how to expire a token with card data: . { \"type\": \"token\", \"data\": { \"number\": \"4242424242424242\", \"expiration_month\": 12, \"expiration_year\": 2025 }, \"expires_at\": \"2025-12-31T00:00:00+00:00\" } . In this example, once the expires_at date has passed, the entire token will be purged and no longer available. ",
    "url": "https://developers.basistheory.com/concepts/what-are-tokens/#time-to-live-ttl",
    "relUrl": "/concepts/what-are-tokens/#time-to-live-ttl"
  },"187": {
    "doc": "Tokens",
    "title": "Auditing",
    "content": "All activities around tokens are audited, including create, read, update, delete and whenever a token is proxied or used in a Reactor. These audit logs are available via the API or the web portal. Also, the creator and last modifier of a token is stored on all tokens. This can be used to lookup which application was used to create or update a token. Request . { \"type\": \"token\", \"data\": \"John Doe\" } . Response . { \"id\": \"c06d0789-0a38-40be-b7cc-c28a718f76f1\", \"type\": \"token\", \"created_by\": \"fb124bba-f90d-45f0-9a59-5edca27b3b4a\", \"created_at\": \"2020-09-15T15:53:00+00:00\", \"modified_by\": \"fb124bba-f90d-45f0-9a59-5edca27b3b4a\", \"modified_at\": \"2020-09-15T15:53:00+00:00\" } . ",
    "url": "https://developers.basistheory.com/concepts/what-are-tokens/#auditing",
    "relUrl": "/concepts/what-are-tokens/#auditing"
  },"188": {
    "doc": "Tokens",
    "title": "Search Indexes",
    "content": "Once data is encrypted, it is difficult to search through the data for business processes without having full access. Basis Theory enables you to create search indexes on parts of the data within a token to allow searching without ever decrypting the underlying data or providing access to the sensitive data. In this example, we have a customer account we want to search over parts of the data: . { \"type\": \"token\", \"data\": { \"first_name\": \"John\", \"last_name\": \"Doe\", \"social_security_number\": \"111-22-3333\", \"email_address\": \"johndoe@basistheory.com\" }, \"search_indexes\": [ \"{{ data.first_name | downcase }}\", \"{{ data.last_name | downcase }}\", \"{{ data.social_security_number }}\", \"{{ data.social_security_number | last4 }}\", \"{{ data.email_address | downcase }}\", \"{{ data.email_address | split: '@' | last }}\" ] } . In the above example, we can now perform a search with john, doe, 111-22-3333, 3333, johndoe@[basistheory.com](http://basistheory.com) or basistheory.com and get back the token. To see all additional capabilities of search, see our API documentation. ",
    "url": "https://developers.basistheory.com/concepts/what-are-tokens/#search-indexes",
    "relUrl": "/concepts/what-are-tokens/#search-indexes"
  },"189": {
    "doc": "Tokens",
    "title": "Deduplication",
    "content": "Duplicate data can be problematic for some systems. This can create data integrity problems in some systems where unique values are required. For example, you may have an accounts payable system and an e-commerce system both accepting credit cards for customers, and you want to ensure duplicate credit cards are not on file for that customer. Deduplication ensures tokens that have the same fingerprint return the same token when created. By default, every tokenization request creates a new token, but with deduplication enabled at the tenant or on each tokenization request, tokens will be deduplicated based upon their fingerprint. This ensures that if multiple systems or the same system creates multiple tokens with the same data, they do not create duplicate tokens. To deduplicate a token during the tokenization request, we pass the deduplicate_token flag to the create token request. This will override the tenant-level deduplicate tokens setting: . { \"type\": \"token\", \"data\": \"123-45-6789\", \"deduplicate_token\": true } . In this scenario, if we detect an existing token with the same fingerprint, the existing token is returned instead of creating a new token. When an existing token is matched, its data and metadata will only be returned within the response if the requester has token:read permission to the matched token. If the requesting Application does not have read permission, then the data, metadata, and other potentially sensitive attributes will be redacted to prevent leaking information to unauthorized parties. Only the following properties will be included in redacted responses: id, type, tenant_id, fingerprint, and containers. ",
    "url": "https://developers.basistheory.com/concepts/what-are-tokens/#deduplication",
    "relUrl": "/concepts/what-are-tokens/#deduplication"
  },"190": {
    "doc": "Tokens",
    "title": "Metadata",
    "content": "Being able to tag your tokens with custom attributes is important in many scenarios. For instance, you may want to add a system identifier to your tokens that allows you to reference a record in your own database. Another scenario is you need to tag records that fall into certain compliance requirements (e.g. GDPR). In these scenarios, putting this information in the token data may not be ideal as you want to be able to quickly reference the information or expose it to audiences who do not have access to view the token data. To solve for this, Basis Theory tokens allow you to set your own metadata on any token utilizing key-value pairs. Request . { \"type\": \"token\", \"data\": \"John Doe\", \"metadata\": { \"customer_id\": \"123abc\" } } . Response . { \"id\": \"a2f1defa-da99-44e7-b70b-4e6dcfa20ec2\", \"type\": \"token\", \"metadata\": { \"customer_id\": \"123abc\" } } . ",
    "url": "https://developers.basistheory.com/concepts/what-are-tokens/#metadata",
    "relUrl": "/concepts/what-are-tokens/#metadata"
  },"191": {
    "doc": "Tokens",
    "title": "Associations",
    "content": "Associations enable you to build relationships between your data. You can construct your relationships into trees or chains enabling you to discover and traverse your data efficiently. You can easily manage the relationship between a parent and child token via our token association API endpoints. ",
    "url": "https://developers.basistheory.com/concepts/what-are-tokens/#associations",
    "relUrl": "/concepts/what-are-tokens/#associations"
  },"192": {
    "doc": "Tokens",
    "title": "Use Cases",
    "content": " ",
    "url": "https://developers.basistheory.com/concepts/what-are-tokens/#use-cases",
    "relUrl": "/concepts/what-are-tokens/#use-cases"
  },"193": {
    "doc": "Tokens",
    "title": "Tokenize Credit Cards",
    "content": "Request . { \"id\": \"{{ data.number | alias_preserve_format }}\", \"type\": \"card\", \"data\": { \"number\": \"4242424242424242\", \"expiration_month\": 12, \"expiration_year\": 2025, \"cvc\": \"123\" }, \"fingerprint_expression\": \"{{ data.number }}\", \"mask\": { \"number\": \"{{ data.number | reveal_last: 4 }}\", \"expiration_month\": \"{{ data.expiration_month }}\", \"expiration_year\": \"{{ data.expiration_year }}\" }, \"search_indexes\": [ \"{{ data.number }}\", \"{{ data.number | last4 }}\" ], \"containers\": [\"/pci/high/\"] } . Response . { \"id\": \"3829018309324938\", \"type\": \"card\", \"data\": { \"number\": \"XXXX XXXX XXXX 4242\", \"expiration_month\": 12, \"expiration_year\": 2025 }, \"fingerprint\": \"M25bjMqlH85LZE2F7SmZ1w\", \"fingerprint_expression\": \"{{ data.number }}\", \"mask\": { \"number\": \"{{ data.number | reveal_last: 4 }}\", \"expiration_month\": \"{{ data.expiration_month }}\", \"expiration_year\": \"{{ data.expiration_year }}\" }, \"search_indexes\": [ \"{{ data.number }}\", \"{{ data.number | last4 }}\" ], \"containers\": [\"/pci/high/\"], \"created_by\": \"fb124bba-f90d-45f0-9a59-5edca27b3b4a\", \"created_at\": \"2020-09-15T15:53:00+00:00\", \"modified_by\": \"fb124bba-f90d-45f0-9a59-5edca27b3b4a\", \"modified_at\": \"2020-09-15T15:53:00+00:00\" } . In order to maintain PCI compliance while capturing credit cards, you will need to use Basis Theory’s card token type or store the CVC in a separate token while setting expires_at TTL property. ",
    "url": "https://developers.basistheory.com/concepts/what-are-tokens/#tokenize-credit-cards",
    "relUrl": "/concepts/what-are-tokens/#tokenize-credit-cards"
  },"194": {
    "doc": "Tokens",
    "title": "Tokenize Bank Data",
    "content": "Request . { \"type\": \"token\", \"data\": { \"routing_number\": \"110000000\", \"account_number\": \"00123456789\" }, \"fingerprint_expression\": \"{{ data.routing_number }}{{ data.account_number }}\", \"mask\": { \"routing_number\": \"{{ data.routing_number }}\", \"account_number\": \"{{ data.account_number | reveal_last: 4 }}\" }, \"search_indexes\": [ \"{{ data.routing_number }}\", \"{{ data.account_number }}\", \"{{ data.account_number | last4 }}\" ], \"containers\": [\"/bank/high/\"] } . Response . { \"id\": \"1457aad3-db95-4b34-8e14-b8ffffc305b4\", \"type\": \"token\", \"data\": { \"routing_number\": \"110000000\", \"account_number\": \"XXXXXXX6789\" }, \"fingerprint\": \"sPbj5G5tKLIX42vrTGgk0Q\", \"fingerprint_expression\": \"{{ data.routing_number }}{{ data.account_number }}\", \"mask\": { \"routing_number\": \"{{ data.routing_number }}\", \"account_number\": \"{{ data.account_number | reveal_last: 4 }}\" }, \"search_indexes\": [ \"{{ data.routing_number }}\", \"{{ data.account_number }}\", \"{{ data.account_number | last4 }}\" ], \"containers\": [\"/bank/high/\"], \"created_by\": \"fb124bba-f90d-45f0-9a59-5edca27b3b4a\", \"created_at\": \"2020-09-15T15:53:00+00:00\", \"modified_by\": \"fb124bba-f90d-45f0-9a59-5edca27b3b4a\", \"modified_at\": \"2020-09-15T15:53:00+00:00\" } . ",
    "url": "https://developers.basistheory.com/concepts/what-are-tokens/#tokenize-bank-data",
    "relUrl": "/concepts/what-are-tokens/#tokenize-bank-data"
  },"195": {
    "doc": "Tokens",
    "title": "Tokenize User Data",
    "content": "Request . { \"type\": \"token\", \"data\": { \"first_name\": \"John\", \"last_name\": \"Doe\", \"social_security_number\": \"111-22-3333\", \"email_address\": \"johndoe@basistheory.com\" }, \"fingerprint_expression\": \"{{ data.social_security_number }}\", \"mask\": { \"first_name\": \"{{ data.first_name }}\", \"last_name\": \"{{ data.last_name | slice: 0 }}.\", \"social_security_number\": \"{{ data.social_security_number | reveal_last: 4 }}\", \"email_address\": \"{{ data.email_address | split: '@' | last }}\" }, \"search_indexes\": [ \"{{ data.first_name | downcase }}\", \"{{ data.last_name | downcase }}\", \"{{ data.social_security_number }}\", \"{{ data.social_security_number | last4 }}\", \"{{ data.email_address | downcase }}\", \"{{ data.email_address | split: '@' | last }}\" ], \"containers\": [\"/pii/high/\"] } . Response . { \"id\": \"be654efd-f748-4dcf-8640-96a1061e29fe\", \"type\": \"token\", \"data\": { \"first_name\": \"John\", \"last_name\": \"D.\", \"social_security_number\": \"XXX-XX-3333\", \"email_address\": \"basistheory.com\" }, \"fingerprint\": \"qRhehf8MqDlEIKPTpQhU6g\", \"fingerprint_expression\": \"{{ data.social_security_number }}\", \"mask\": { \"first_name\": \"{{ data.first_name }}\", \"last_name\": \"{{ data.last_name | slice: 0 }}.\", \"social_security_number\": \"{{ data.social_security_number | reveal_last: 4 }}\", \"email_address\": \"{{ data.email_address | split: '@' | last }}\" }, \"search_indexes\": [ \"{{ data.first_name | downcase }}\", \"{{ data.last_name | downcase }}\", \"{{ data.social_security_number }}\", \"{{ data.social_security_number | last4 }}\", \"{{ data.email_address | downcase }}\", \"{{ data.email_address | split: '@' | last }}\" ], \"containers\": [\"/pii/high/\"], \"created_by\": \"fb124bba-f90d-45f0-9a59-5edca27b3b4a\", \"created_at\": \"2020-09-15T15:53:00+00:00\", \"modified_by\": \"fb124bba-f90d-45f0-9a59-5edca27b3b4a\", \"modified_at\": \"2020-09-15T15:53:00+00:00\" } . ",
    "url": "https://developers.basistheory.com/concepts/what-are-tokens/#tokenize-user-data",
    "relUrl": "/concepts/what-are-tokens/#tokenize-user-data"
  },"196": {
    "doc": "Tokens",
    "title": "Tokenize Credentials",
    "content": "Request . { \"type\": \"token\", \"data\": { \"username\": \"johndoe\", \"password\": \"8n%C%r+4DG*7BdPjZ6km9Nc#\" }, \"expires_at\": \"2022-07-15T00:00:00+00:00\", \"containers\": [\"/general/high/\"] } . Response . { \"id\": \"4bc29335-38fd-4f71-8f36-c63ee8965be7\", \"type\": \"token\", \"fingerprint\": \"Rs2U7r4cwN137j9XRO88zg\", \"fingerprint_expression\": \"{{ data | stringify }}\", \"expires_at\": \"2022-07-15T00:00:00+00:00\", \"containers\": [\"/general/high/\"], \"created_by\": \"fb124bba-f90d-45f0-9a59-5edca27b3b4a\", \"created_at\": \"2020-09-15T15:53:00+00:00\", \"modified_by\": \"fb124bba-f90d-45f0-9a59-5edca27b3b4a\", \"modified_at\": \"2020-09-15T15:53:00+00:00\" } . ",
    "url": "https://developers.basistheory.com/concepts/what-are-tokens/#tokenize-credentials",
    "relUrl": "/concepts/what-are-tokens/#tokenize-credentials"
  },"197": {
    "doc": "Search",
    "title": "What is Search?",
    "content": "Encrypting data has always come with one costly tradeoff: it makes searching over your data very complicated. Basis Theory’s search feature aims to make that as simple and painless as possible, without any need to detokenize or decrypt your data. ",
    "url": "https://developers.basistheory.com/concepts/what-is-search/#what-is-search",
    "relUrl": "/concepts/what-is-search/#what-is-search"
  },"198": {
    "doc": "Search",
    "title": "How It Works",
    "content": "When a Token is created, the data is securely indexed in several data patterns using blind indexes. Combining the blind indexes with the existing metadata on the tokens allows you to search your entire Vault with a simple query. You can search over the following fields: . | id | type | data | fingerprint | container | metadata.[key] | created_by | created_at | modified_by | modified_at | . Searching data is not limited by token type. It is entirely driven by the presence of search indexes, which is an array of search index expressions that can be specified within the request when creating a token. Some token types have default search indexes, but they can be overridden with custom indexes to fit your use case. ",
    "url": "https://developers.basistheory.com/concepts/what-is-search/#how-it-works",
    "relUrl": "/concepts/what-is-search/#how-it-works"
  },"199": {
    "doc": "Search",
    "title": "Permissions",
    "content": "In order to search Tokens using the API, you must use an Application with the token:search permission. The search results are filtered based on the permissions associated with the Application; you cannot search for tokens you do not have permission to access. ",
    "url": "https://developers.basistheory.com/concepts/what-is-search/#permissions",
    "relUrl": "/concepts/what-is-search/#permissions"
  },"200": {
    "doc": "Search",
    "title": "Query Syntax",
    "content": "Basis Theory uses a Lucene-based query syntax to power the search engine. Searching is case-insensitive, however only exact matches are currently supported. Wildcard searches are not available at this time. The search query is a string with one or more terms in the format field:value. For instance, if you want to find all social security numbers, you would query: . type:social_security_number . To search Token data on Types that support it, you can search for the indexed data patterns. To search for Tokens containing the data 123-45-6789, you would query: . data:123-45-6789 . If you are searching over data that contains multiple words or spaces, you can wrap the search value in quotes: . data:\"data containing multiple words\" . Searching Tokens using metadata is supported as well. Metadata search terms use dot notation for key in the form of metadata.key:value. For example, to search for Tokens having the metadata { customer_id: \"123456\" }, query for: . metadata.customer_id:123456 . Date range searches are supported using the Lucene bracketed range syntax. [START_DATE TO END_DATE] denotes an inclusive range and {START_DATE TO END_DATE} denotes an exclusive range. Values are formatted as a string in ISO 8601 format and can either represent a date or date and time in UTC. For example, to search for tokens that were created in the year 2021, you can query: . created_at:[2021-01-01 TO 2021-12-31T23:59:59Z] . To search a range without a start or end date, use the wildcard * in place of the start or end date, for example: . created_at:{* TO 2022-01-01} . Multiple terms may be combined using the AND and OR operators and grouped using parentheses. For example: . (type:social_security_number AND metadata.user_id:1234) OR data:111-11-1111 . Only the Lucene query operators described above are supported at this time. If you would like to have support for any additional Lucene features, please let us know. ",
    "url": "https://developers.basistheory.com/concepts/what-is-search/#query-syntax",
    "relUrl": "/concepts/what-is-search/#query-syntax"
  },"201": {
    "doc": "Search",
    "title": "FAQ",
    "content": "What is the difference between Search and Fingerprints? . Fingerprints are a measure of uniqueness, not a representation of the underlying data. Fingerprints can be used to locate duplicate data, for instance, but do not allow you to find specific data. You cannot find a card number ending in 4242 with fingerprints. How does searching Tokens affect my Monthly Active Token usage? . Each Token that matches the search query made via the API and is returned in the result set becomes an Active Token for that month. Searching through the Portal as a logged in user will not affect MAT usage. ",
    "url": "https://developers.basistheory.com/concepts/what-is-search/#faq",
    "relUrl": "/concepts/what-is-search/#faq"
  },"202": {
    "doc": "Search",
    "title": "Search",
    "content": " ",
    "url": "https://developers.basistheory.com/concepts/what-is-search/",
    "relUrl": "/concepts/what-is-search/"
  },"203": {
    "doc": "Proxy",
    "title": "What Is the Proxy?",
    "content": "It is a common need to share data between software systems via HTTP based APIs, but what if the HTTP request requires a piece of sensitive data that you have tokenized and do not want to access directly within your application? . The Proxy enables you to build HTTP requests containing sensitive tokenized data and send them from your systems in a secure and compliant manner without needing to access raw token data. Your application can include token identifiers within the request payload and send this request through Basis Theory’s systems to substitute token data into the request before forwarding it to the desired destination. The end result is that you can call HTTP APIs with tokenized data without needing to touch the underlying sensitive data directly within your systems. ",
    "url": "https://developers.basistheory.com/concepts/what-is-the-proxy/#what-is-the-proxy",
    "relUrl": "/concepts/what-is-the-proxy/#what-is-the-proxy"
  },"204": {
    "doc": "Proxy",
    "title": "How It Works",
    "content": "Your system initiates an outbound HTTP request to the Proxy hosted by Basis Theory. The request is transformed by evaluating any expressions included in the request (patterns of the form {{&lt;tokenId&gt;}}, where &lt;tokenId&gt; is the id of a token created within your tenant). Any detokenization expressions will be replaced with the detokenized data value of this token. Finally, the request is delivered to the destination URL that was specified through a BT-PROXY-URL HTTP header. The Proxy terminates the inbound TLS connection from your servers and initiates a new TLS connection to the destination in order to guarantee secure transmission of your sensitive token data. For this reason, we require the destination servers to support TLSv1.2+ and that the provided destination URL uses https. The application that is being used to call the Proxy must be granted token:use permission on any tokens that are detokenized. It is recommended that you restrict which tokens the Proxy can detokenize by only granting token:use permission on the most-specific container of tokens that is required. Whatever the content type or HTTP method, any HTTP request can be sent through the proxy simply by adding the headers BT-API-KEY and BT-PROXY-URL. For example: . curl \"https://api.basistheory.com/proxy\" \\ -H \"BT-API-KEY: key_NS21v84n7epsSc5WzoFjM6\" \\ -H \"BT-PROXY-URL: https://my-destination-api.com\" \\ -H \"Content-Type: application/json\" \\ -X \"POST\" \\ -d '{ \"sensitive\": \"{{e51b0ff4-aa80-407a-b628-3909c26ff397}}\", \"nonSensitive\": \"plaintext data can go here\" }' . For further details about how to use the Proxy, check out our docs. ",
    "url": "https://developers.basistheory.com/concepts/what-is-the-proxy/#how-it-works",
    "relUrl": "/concepts/what-is-the-proxy/#how-it-works"
  },"205": {
    "doc": "Proxy",
    "title": "Common Use Cases",
    "content": "Share Sensitive Data with a Third Party . Tokenized data can be included in any HTTP request to a third party API by executing the HTTP request through the Proxy. This makes it easy to share sensitive data with a third party without needing to first retrieve and manipulate this sensitive data on your servers. Upgrade an Existing System . In existing systems with sensitive data you wish to secure, this data can be migrated and tokenized with Basis Theory. Once safely tokenized, your systems still need to utilize this data with your existing HTTP calls without pulling the raw values back into your system. For this, you can leverage the Proxy in order to minimize the impact of this change on your existing codebase. ",
    "url": "https://developers.basistheory.com/concepts/what-is-the-proxy/#common-use-cases",
    "relUrl": "/concepts/what-is-the-proxy/#common-use-cases"
  },"206": {
    "doc": "Proxy",
    "title": "Samples",
    "content": "Use Token Data in HTTP Requests . ",
    "url": "https://developers.basistheory.com/concepts/what-is-the-proxy/#samples",
    "relUrl": "/concepts/what-is-the-proxy/#samples"
  },"207": {
    "doc": "Proxy",
    "title": "FAQs",
    "content": "How to Choose Between the Proxy and Serverless Reactors . Basis Theory offers a number of out-of-the-box integrations to share your tokenized data with Third Party systems via our Serverless Reactor platform. However, you may require an integration that is not yet supported, in which case you have a few options to choose from: . | Create a custom Reactor Formula containing the code required to integrate with the third party system (our serverless platform executes this code) | Use the Proxy to send the API request from your own application (your servers execute this code) | . Using the Proxy can provide a quicker and lower configuration option for making custom HTTP requests to a third party API than writing and maintaining a custom reactor formula. ",
    "url": "https://developers.basistheory.com/concepts/what-is-the-proxy/#faqs",
    "relUrl": "/concepts/what-is-the-proxy/#faqs"
  },"208": {
    "doc": "Proxy",
    "title": "Proxy",
    "content": " ",
    "url": "https://developers.basistheory.com/concepts/what-is-the-proxy/",
    "relUrl": "/concepts/what-is-the-proxy/"
  }
}
